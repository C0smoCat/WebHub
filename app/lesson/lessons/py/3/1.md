# Списки, кортежи и словари

## Список

Для работы с наборами данных Python предоставляет такие встроенные типы как списки, кортежи и словари.

Список (list) представляет тип данных, который хранит набор или последовательность элементов. Для создания списка в квадратных скобках ([]) через запятую перечисляются все его элементы. Во многих языках программирования есть аналогичная структура данных, которая называется массив. Например, определим список чисел:

```py
numbers = [1, 2, 3, 4, 5]
```

Также для создания списка можно использовать конструктор **list()**:

```py
numbers1 = []
numbers2 = list()
```

Оба этих определения списка аналогичны - они создают пустой список.

Конструктор list для создания списока может принимать другой список:

```py
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers2 = list(numbers)
```

Для обращения к элементам списка надо использовать индексы, которые представляют номер элемента в списка. Индексы начинаются с нуля. То есть второй элемент будет иметь индекс 1. Для обращения к элементам с конца можно использовать отрицательные индексы, начиная с -1. То есть у последнего элемента будет индекс -1, у предпоследнего - -2 и так далее.

```py
numbers = [1, 2, 3, 4, 5]
print(numbers[0])   # 1
print(numbers[2])   # 3
print(numbers[-3])  # 3

numbers[0] = 125  # изменяем первый элемент списка
print(numbers[0])   # 125
```

Если необходимо создать список, в котором повторяется одно и то же значение несколько раз, то можно использовать символ звездочки *. Например, определим список из шести пятерок:

```py
numbers = [5] * 6  # [5, 5, 5, 5, 5, 5]
print(numbers)
```

Кроме того, если нам необходим последовательный список чисел, то для его создания удобно использовать функцию **range**, которая имеет три формы:
- `range(end)`: создается набор чисел от 0 до числа end
- `range(start, end)`: создается набор чисел от числа start до числа end
- `range(start, end, step)`: создается набор чисел от числа start до числа end с шагом step

```py
numbers = list(range(10))
print(numbers)      # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(2, 10))
print(numbers)      # [2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(10, 2, -2))
print(numbers)      # [10, 8, 6, 4]
```

Например, следующие два определения списка будут аналогичны, но за счет функции range мы сокращаем объем кода:

```py
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers2 = list(range(1, 10))
```

Список необязательно должен содержать только однотипные объекты. Мы можем поместить в один и тот же список одновременно строки, числа, объекты других типов данных:

```py
objects = [1, 2.6, "Hello", True]
```

### Перебор элементов

Для перебора элементов можно использовать как цикл for, так и цикл while.

Перебор с помощью цикла for:

```py
companies = ["Microsoft", "Google", "Oracle", "Apple"]
for item in companies:
    print(item)
```

Здесь вместо функции range мы сразу можем подставить имеющийся список companies.

Перебор с помощью цикла while:

```py
companies = ["Microsoft", "Google", "Oracle", "Apple"]
i = 0
while i < len(companies):
    print(companies[i])
    i += 1
```

Для перебора с помощью функции **len()** получаем длину списка. С помощью счетчика i выводит по элементу, пока значение счетчика не станет равно длине списка.

### Сравнение списков

Два списка считаются равными, если они содержат один и тот же набор элементов:

```py
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers2 = list(range(1,10))
if numbers == numbers2:
    print("numbers equal to numbers2")
else:
    print("numbers is not equal to numbers2")
```

В данном случае оба списка будут равны.

### Методы и функции по работе со списками

Для управления элементами списки имеют целый ряд методов. Некоторые из них:
- **append(item)**: добавляет элемент item в конец списка
- **insert(index, item)**: добавляет элемент item в список по индексу index
- **remove(item)**: удаляет элемент item. Удаляется только первое вхождение элемента. Если элемент не найден, генерирует исключение ValueError
- **clear()**: удаление всех элементов из списка
- **index(item)**: возвращает индекс элемента item. Если элемент не найден, генерирует исключение ValueError
- **pop([index])**: удаляет и возвращает элемент по индексу index. Если индекс не передан, то просто удаляет последний элемент.
- **count(item)**: возвращает количество вхождений элемента item в список
- **sort([key])**: сортирует элементы. По умолчанию сортирует по возрастанию. Но с помощью параметра key мы можем передать функцию сортировки.
- **reverse()**: расставляет все элементы в списке в обратном порядке

Кроме того, Python предоставляет ряд встроенных функций для работы со списками:
- **len(list)**: возвращает длину списка
- **sorted(list, [key])**: возвращает отсортированный список
- **min(list)**: возвращает наименьший элемент списка
- **max(list)**: возвращает наибольший элемент списка

### Добавление и удаление элементов

Для добавления элемента применяются методы `append()` и `insert`, а для удаления - методы `remove()`, `pop()` и `clear()`.

Использование методов:

```py
users = ["Tom", "Bob"]

# добавляем в конец списка
users.append("Alice")  # ["Tom", "Bob", "Alice"]
# добавляем на вторую позицию
users.insert(1, "Bill")          # ["Tom", "Bill", "Bob", "Alice"]

# получаем индекс элемента
i = users.index("Tom")
# удаляем по этому индексу
removed_item = users.pop(i)            # ["Bill", "Bob", "Alice"]

last_user = users[-1]
# удаляем последний элемент
users.remove(last_user)           # ["Bill", "Bob"]

print(users)

# удаляем все элементы
users.clear()
```

### Проверка наличия элемента

Если определенный элемент не найден, то методы remove и index генерируют исключение. Чтобы избежать подобной ситуации, перед операцией с элементом можно проверять его наличие с помощью ключевого слова **in**:

```py
companies = ["Microsoft", "Google", "Oracle", "Apple"]
item = "Oracle"  # элемент для удаления
if item in companies:
    companies.remove(item)

print(companies)
```

Выражение `item in companies` возвращает True, если элемент item имеется в списке companies. Поэтому конструкция `if item in companies` может выполнить последующий блок инструкций в зависимости от наличия элемента в списке.

### Подсчет вхождений

Если необходимо узнать, сколько раз в списке присутствует тот или иной элемент, то можно применить метод `count()`:

```py
users = ["Tom", "Bob", "Alice", "Tom", "Bill", "Tom"]

users_count = users.count("Tom")
print(users_count)      # 3
```

### Сортировка

Для сортировки по возрастанию применяется метод **sort()**:

```py
users = ["Tom", "Bob", "Alice", "Sam", "Bill"]

users.sort()
print(users)      # ["Alice", "Bill", "Bob", "Sam", "Tom"]
```

Если необходимо отсортировать данные в обратном порядке, то мы можем после сортировки применить метод `reverse()`:

```py
users = ["Tom", "Bob", "Alice", "Sam", "Bill"]

users.sort()
users.reverse()
print(users)      # ["Tom", "Sam", "Bob", "Bill", "Alice"]
```

При сортировке фактически сравниваются два объекта, и который из них "меньше", ставится перед тем, который "больше". Понятия "больше" и "меньше" довольно условны. И если для чисел все просто - числа расставляются в порядке возрастания, то для строк и других объектов ситуация сложнее. В частности, строки оцениваются по первым символам. Если первые символы равны, оцениваются вторые символы и так далее. При чем цифровой символ считается "меньше", чем алфавитный заглавный символ, а заглавный символ считается меньше, чем строчный. Подробнее про сравнение строк описывалось в статье [Операции со строками](2.5.php).

Таким образом, если в списке сочетаются строки с верхним и нижним регистром, то мы можем получить не совсем корректные результаты, так как для нас строка "bob" должна стоять до строки "Tom". И чтобы изменить стандартное поведение сортировки, мы можем передать в метод `sort()` в качестве параметра функцию:

```py
users = ["Tom", "bob", "alice", "Sam", "Bill"]

users.sort(key=str.lower)
print(users)      # ["alice", "Bill", "bob", "Sam", "Tom"]
```

Кроме метода sort мы можем использовать встроенную функцию **sorted**, которая имеет две формы:
- `sorted(list)`: сортирует список list
- `sorted(list, key)`: сортирует список list, применяя к элементам функцию key

```py
users = ["Tom", "bob", "alice", "Sam", "Bill"]

sorted_users = sorted(users, key=str.lower)
print(sorted_users)      # ["alice", "Bill", "bob", "Sam", "Tom"]
```

При использовании этой функции следует учитывать, что эта функция не изменяет сортируемый список, а все отсортированные элементы она помещает в новый список, который возвращается в качестве результата.

### Минимальное и максимальное значения

Встроенный функции Python `min()` и `max()` позволяют найти минимальное и максимальное значения соответственно:

```py
numbers = [9, 21, 12, 1, 3, 15, 18]
print(min(numbers))     # 1
print(max(numbers))     # 21
```

### Копирование списков

При копировании списков следует учитывать, что списки представляют изменяемый (mutable) тип, поэтому если обе переменных будут указывать на один и тот же список, то изменение одной переменной, затронет и другую переменную:

```py
users1 = ["Tom", "Bob", "Alice"]
users2 = users1
users2.append("Sam")
# users1 и users2 указывают на один и тот же список
print(users1)   # ["Tom", "Bob", "Alice", "Sam"]
print(users2)   # ["Tom", "Bob", "Alice", "Sam"]
```

Это так называемое "поверхностное копирование" (shallow copy). И, как правило, такое поведение нежелательное. И чтобы происходило копирование элементов, но при этом переменные указывали на разные списки, необходимо выполнить глубокое копирование (deep copy). Для этого можно использовать метод **deepcopy()**, который определен во встроенном модуле **copy**:

```py
import copy

users1 = ["Tom", "Bob", "Alice"]
users2 = copy.deepcopy(users1)
users2.append("Sam")
# пееменные users1 и users2 указывают на разные списки
print(users1)   # ["Tom", "Bob", "Alice"]
print(users2)   # ["Tom", "Bob", "Alice", "Sam"]
```

### Копирование части списка

Если необходимо скопировать не весь список, а только его какую-то определенную часть, то мы можем применять специальный синтаксис. который может принимать следующие формы:
- `list[:end]`: через параметр end передается индекс элемента, до которого нужно копировать список
- `list[start:end]`: параметр start указывает на индекс элемента, начиная с которого надо скопировать элементы
- `list[start:end:step]`: параметр step указывает на шаг, через который будут копироваться элементы из списка. По умолчанию этот параметр равен 1.

```py
users = ["Tom", "Bob", "Alice", "Sam", "Tim", "Bill"]

slice_users1 = users[:3]   # с 0 по 3
print(slice_users1)   # ["Tom", "Bob", "Alice"]

slice_users2 = users[1:3]   # с 1 по 3
print(slice_users2)   # ["Bob", "Alice"]

slice_users3 = users[1:6:2]   # с 1 по 6 с шагом 2
print(slice_users3)   # ["Bob", "Sam", "Bill"]
```

### Соединение списков

Для объединения списков применяется операция сложения (+):

```py
users1 = ["Tom", "Bob", "Alice"]
users2 = ["Tom", "Sam", "Tim", "Bill"]
users3 = users1 + users2
print(users3)   # ["Tom", "Bob", "Alice", "Tom", "Sam", "Tim", "Bill"]
```

### Списки списков

Списки кроме стандартных данных типа строк, чисел, также могут содержать другие списки. Подобные списки можно ассоциировать с таблицами, где вложенные списки выполняют роль строк. Например:

```py
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

print(users[0])         # ["Tom", 29]
print(users[0][0])      # Tom
print(users[0][1])      # 29
```

Чтобы обратиться к элементу вложенного списка, необходимо использовать пару индексов: `users[0][1]` - обращение ко второму элементу первого вложенного списка.

Добавление, удаление и исменение общего списка, а также вложенных списков аналогично тому, как это делается с обычными (одномерными) списками:

```py
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

# создание вложенного списка
user = list()
user.append("Bill")
user.append(41)
# добавление вложенного списка
users.append(user)

print(users[-1])         # ["Bill", 41]

# добавление во вложенный список
users[-1].append("+79876543210")

print(users[-1])         # ["Bill", 41, "+79876543210"]

# удаление последнего элемента из вложенного списка
users[-1].pop()
print(users[-1])         # ["Bill", 41]

# удаление всего последнего вложенного списка
users.pop(-1)

# изменение первого элемента
users[0] = ["Sam", 18]
print(users)            # [ ["Sam", 18], ["Alice", 33], ["Bob", 27]]
```

Перебор вложенных списков:

```py
users = [
    ["Tom", 29],
    ["Alice", 33],
    ["Bob", 27]
]

for user in users:
    for item in user:
        print(item, end=" | ")
```

Консольный вывод:

```

```


> Материал взят с сайта metanit.com