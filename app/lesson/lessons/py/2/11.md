## Обработка исключений

При программировании на Python мы можем столкнуться с двумя типами ошибок. Первый тип представляют **синтаксические ошибки** (syntax error). Они появляются в результате нарушения синтаксиса языка программирования при написании исходного кода. При наличии таких ошибок программа не может быть скомпилирована. При работе в какой-либо среде разработки, например, в PyCharm, IDE сама может отслеживать синтаксические ошибки и каким-либо образом их выделять.

Второй тип ошибок представляют **ошибки выполнения** (runtime error). Они появляются в уже скомпилированной программе в процессе ее выполнения. Подобные ошибки еще называются исключениями. Например, в прошлых темах мы рассматривали преобразование числа в строку:

```py
string = "5"
number = int(string)
print(number)
```

Данный скрипт успешно скомпилируется и выполнится, так как строка "5" вполне может быть конвертирована в число. Однако возьмем другой пример:

```py
string = "hello"
number = int(string)
print(number)
```

При выполнении этого скрипта будет выброшено исключение ValueError, так как строку "hello" нельзя преобразовать в число. С одной стороны, здесь очевидно, сто строка не представляет число, но мы можем иметь дело с вводом пользователя, который также может ввести не совсем то, что мы ожидаем:

```py
string = input("Введите число: ")
number = int(string)
print(number)
```

При возникновении исключения работа программы прерывается, и чтобы избежать подобного поведения и обрабатывать исключения в Python есть конструкция **try..except**, которая имеет следующее формальное определение:

```py
try:
    инструкции
except [Тип_исключения]:
    инструкции
```

Весь основной код, в котором потенциально может возникнуть исключение, помещается после ключевого слова **try**. Если в этом коде генерируется исключение, то работа кода в блоке try прерывается, и выполнение переходит в блок **except**.

После ключевого слова **except** опционально можно указать, какое исключение будет обрабатываться (например, ValueError или KeyError). После слова except на следующей стоке идут инструкции блока except, выполняемые при возникновении исключения.

Рассмотрим обработку исключения на примере преобразовании строки в число:

```py
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except:
    print("Преобразование прошло неудачно")
print("Завершение программы")
```

Вводим строку:

```

```

Как видно из консольного вывода, при вводе строки вывод числа на консоль не происходит, а выполнение программы переходит к блоку except.

Вводим правильное число:

```

```

Теперь все выполняется нормально, исключение не возникает, и соответственно блок except не выполняется.

В примере выше обрабатывались сразу все исключения, которые могут возникнуть в коде. Однако мы можем конкретизировать тип обрабатываемого исключения, указав его после слова except:

```py
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError:
    print("Преобразование прошло неудачно")
print("Завершение программы")
```

Если ситуация такова, что в программе могут быть сгенерированы различные типы исключений, то мы можем их обработать по отдельности, используя дополнительные выражения except:

```py
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except ValueError:
    print("Преобразование прошло неудачно")
except ZeroDivisionError:
    print("Попытка деления числа на ноль")
except Exception:
    print("Общее исключение")
print("Завершение программы")
```

Если возникнет исключение в результате преобразования строки в число, то оно будет обработано блоком `except ValueError`. Если же второе число будет равно нулю, то есть будет деление на ноль, тогда возникнет исключение ZeroDivisionError, и оно будет обработано блоком `except ZeroDivisionError`.

Тип **Exception** представляет общее исключение, под которое попадают все исключительные ситуации. Поэтому в данном случае любое исключение, которое не представляет тип ValueError или ZeroDivisionError, будет обработано в блоке `except Exception:`.

### Блок finally

При обработке исключений также можно использовать необязательный блок **finally**. Отличительной особенностью этого блока является то, что он выполняется вне зависимости, было ли сгенерировано исключение:

```py
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError:
    print("Не удалось преобразовать число")
finally:
    print("Блок try завершил выполнение")
print("Завершение программы")
```

Как правило, блок finally применяется для освобождения используемых ресурсов, например, для закрытия файлов.

### Получение информации об исключении

С помощью оператора **as** мы можем передать всю информацию об исключении в переменную, которую затем можно использовать в блоке except:

```py
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError as e:
    print("Сведения об исключении", e)
print("Завершение программы")
```

Пример некорректного ввода:

```

```

### Генерация исключений

Иногда возникает необходимость вручную сгенерировать то или иное исключение. Для этого применяется оператор **raise**.

```py
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    if number2 == 0:
        raise Exception("Второе число не должно быть равно 0")
    print("Результат деления двух чисел:", number1/number2)
except ValueError:
    print("Введены некорректные данные")
except Exception as e:
    print(e)
print("Завершение программы")
```

При вызове исключения мы можем ему передать сообщение, которое затем можно вывести пользователю:

```

```


> Материал взят с сайта metanit.com