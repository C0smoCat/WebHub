## Классы

С внедреием стандарта ES2015 (ES6) в JavaScript появился новый способ определения объектов - с помощью классов. Класс представляет описание объекта, его состояния и поведения, 
а объект является конкретным воплощением или экземпляром класса.

Для определения класса используется ключевое слово **class**:

```js
class Person{
}
```

После слова `class` идет название класса (в данном случае класс называется Person), и затем в фигурных скобках определяется тело класса.

Также можно определить анонимный класс и присвоить его переменной:

```js
let Person = class{}
```

После этого мы можем создать объекты класса с помощью конструктора:

```js
class Person{}

let tom = new Person();
let bob = new Person();
```

Для создания объекта с помощью конструктора сначала ставится ключевое слово **new**. Затем собственно идет вызов конструктора - по сути 
вызов функции по имени класса. По умолчанию классы имеют один конструктор без параметров. Поэтому в данном случае при вызове конструктора в него не передается 
никаких аргументов.

Также мы можем определить в классе свои конструкторы. Также класс может содержать свойства и методы:

```js
class Person{
	constructor(name, age){
		this.name = name;
		this.age = age;
	}
	display(){
		console.log(this.name, this.age);
	}
}

let tom = new Person("Tom", 34);
tom.display();			// Tom 34
console.log(tom.name);	// Tom
```

Конструктор определяется с помощью метода с именем **constructor**. По сути это обычный метод, который может принимать параметры. 
Основная цель конструктора - инициализировать объект начальными данными. И в данном случае в конструктор передаются два значения - для имени и возраста пользователя.

Для хранения состояния в классе определяются свойства. Для их определения используется ключевое слово **this**. В данном случае 
в классе два свойства: name и age.

Поведение класса определяют методы. В данном случае определен метод `display()`, который выводит значения свойств на консоль.

Поскольку мы определили конструктор, который принимает два параметра, то соответственно мы можем передать в конструктор два значения для инициализации 
объекта: `new Person("Tom", 34)`.

### Наследование

Одни классы могут наследоваться от других. Наследование позволяет сократить объем кода в классах-наследниках. Например, определим следеющие классы:

```js
class Person{
	constructor(name, age){
		this.name = name;
		this.age = age;
	}
	display(){
		console.log(this.name, this.age);
	}
}
class Employee extends Person{
	constructor(name, age, company){
		super(name, age);
		this.company = company;
	}
	display(){
		super.display();
		console.log("Employee in", this.company);
	}
	work(){
		console.log(this.name, "is hard working");
	}
}

let tom = new Person("Tom", 34);
let bob = new Employee("Bob", 36, "Google");
tom.display();
bob.display();
bob.work();
```

Для наследования одного класса от другого в определении класса применяется оператор **extends**, после которого идет название базового класса. 
То есть в данном случае класс Employee наследуется от класса Person. Класс Person еще называется базовым классом, классом-родителем, суперклассом, а класс 
Employee - классом-наследником, подклассом, производным классом.

Производный класс, как и базовый, может определять конструкторы, свойства, методы. Вместе с тем с помощью слова **super** производный класс может 
ссылаться на функционал, определенный в базовом. Например, в конструкторе Employee можно вручную не устанавливать свойства name и age, а с помощью выражения 
`super(name, age);` вызвать конструктор базового класса и тем самым передать работу по установке этих свойств базовому классу.

Подобным образом в методе display в классе Employee через вызов `super.display()` можно обратиться к реализации метода display класса Person.

Консольный вывод программы:

```browser
Tom 34
Bob 36
Employee in Google
Bob is hard working
```

### Статические методы

Статические методы вызываются для всего класса вцелом, а не для отедельного объекта. Для их определения применяется оператор **static**. Например:

```js
class Person{
	constructor(name, age){
		this.name = name;
		this.age = age;
	}
	static nameToUpper(person){
		return person.name.toUpperCase();
	}
	display(){
		console.log(this.name, this.age);
	}
}
let tom = new Person("Tom Soyer", 34);
let personName = Person.nameToUpper(tom);
console.log(personName);		// TOM SOYER
```

В данном случае определен статический метод `nameToUpper()`. В качестве параметра он принимает объект Person и переводит его имя в верхний 
регистр. Поскольку статический метод относится классу вцелом, а не к объекту, то мы НЕ можем использовать в нем ключевое слово this и через него обращаться к свойствам 
объекта.

