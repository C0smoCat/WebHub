Наследование является одним из основных аспектов объектно-ориентированного программирования. Наследование позволяет переопределить функционал уже имеющихся классов в классах-наследниках. Если у нас есть какой-нибудь класс, в котором не хватает пары функций, то гораздо проще переопределить имеющийся класс, написав пару строк, чем создавать новый с нуля, переписывая кучу кода.

Чтобы наследовать один класс от другого, нам надо применить инструкцию **extends**. Например, унаследуем класс Customer от класса User:

```php
<?php
class User
{
    public $name, $age;
     
    function __construct($name, $age)
    {
        $this->name = $name;
        $this->age = $age;
    }
    function getClassInfo()
    {
        echo "Класс User описывает пользователей<br />";
    }
    function getInfo()
    {
        echo "Имя: $this->name ; Возраст: $this->age <br />";
    }
}
class Customer extends User
{
    public $account, $sum;
     
    function __construct($name, $age, $acc)
    {
        // вызов конструктора базового класс
        parent::__construct($name, $age);
        $this->account=$acc;
        $this->sum=20;
    }
     
    // скрывает родительский метод getClassInfo()
    function getClassInfo()
    {
        echo "Класс Customer описывает клиентов <br />";
    }
     
    function getInfo()
    {
        parent::getInfo();
        echo "Номер счета $this->account ; Сумма: $this->sum <br />";
    }
}
 
$client = new Customer("Джон", 25, "1123400895");
$client->getInfo();
$client->getClassInfo();
?>
```

Класс Customer наследует от класса-родителя User весь функционал, а также добавляет два дополнительных свойства `$account` и `$sum`. И несмотря на то, что свойство `$name` определено в классе User, его также можно получить из класса Customer: `$this ->name`

Если в классе-наследнике определен метод с тем же именем, что и в классе-родителе, то метод класса-наследника замещает метод класса-родителя. В нашем случае в обоих классах определен метод `getClassInfo()`, поэтому Customer будет обращаться к своему методу `getClassInfo()`.

Если нам надо обратиться к методу родительского класса, то мы можем использовать инструкцию **parent**:

```php
parent::getInfo();
```

И при вызове метода `getInfo()` из класса Customer сначала будет вызываться метод `getInfo()` родительского класса User, а затем остальные инструкции:

```php
function getInfo()
{
    parent::getInfo();
    echo "Номер счета $this->account ; Сумма: $this->sum <br>";
}
```

Класс Customer также определяет свой конструктор:

```php
function __construct($name, $age, $acc)
{
    // вызов конструктора базового класс
    parent::__construct($name, $age);
    $this->account=$acc;
    $this->sum=20;
}
```

Здесь также сначала идет обращение к конструктору класса-родителя, чтобы он сам выполнил установку свойств `$name` и `$age`.

## Запрет наследования и инструкция final

В примере выше методы `getInfo()` и `getClassInfo()` переопределяются классом-наследником. Однако иногда возникают ситуации, когда надо запретить переопределение методов. Для этого в классе-родителе надо указать методы с модификатором **final**:

```php
class User
{
    //.........................
     
    final function getInfo()
    {
        echo "Имя: $this->name ; Возраст: $this->age <br />";
    }
}
```

В этом случае во всех классах-наследниках от класса User мы уже не сможем определить метод с таким же именем.