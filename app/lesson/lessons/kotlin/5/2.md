## Обработка исключений

Исключение представляет событие, которое возникает при выполнении программы и нарушает ее нормальной ход. Например, при передаче файла по сети может оборваться сетевое подключение, и в результате чего может быть сгенерировано исключение. Если исключение не обработано, то программа падает и прекращает свою работу. Поэтому при возникновении исключений их следует обрабатывать.

Для обработки исключений применяется конструкция **try..catch..finally**. В блок **try** помещаются те действия, которые потенциально могут вызвать исключение (например, передача файла по сети, открытие файла и т.д.). Блок **catch** перехватывает возникшее исключение и обрабатывает его. Блок **finally** выполняет некоторые завершающие действия.

```kotlin
try {
    // код, генерирующий исключение
}
catch (e: Exception) {
    // обработка исключения
}
finally {
    // постобработка
}
```

После оператора catch в скобках помещается параметр, который представляет тип исключения. Из этого параметра можно получить информацию о произошедшем исключении.

Блок finally является необязательным, его можно опустить. Блок catch также может отсутствовать, однако обязательно должен быть блок try и как минимум один из блоков: либо catch, либо finally. Также конструкция может содержать несколько блоков catch для обработки каждого типа исключения, которое может возникнуть.

Блок catch выполняется, если только возникло исключение. Блок finally выполняется в любом случае, даже если нет исключения.

Например, при делении на ноль Kotlin генерирует исключение:

```kotlin
fun main(args: Array<String>) {

   try{
       val x : Int = 0
       val z : Int = 0 / x
       println("z = $z")
   }
   catch(e: Exception) {
       println("Exception")
       println(e.message)
   }
}
```

Действие, которое может вызвать исключение, то есть операция деления, помещается в блок try. В блоке catch перехватываем исключение. При этом каждое исключение имеет определенный тип. В данном случае используется общий тип исключений - класс **Exception**. Через свойство `message` этого класса мы можем получить собственно сообщение об исключении. Так, в данном случае при выполнении программы мы получим следующий консольный вывод:

```

```

Если необходимы какие-то завершающие действия, то можно добавить блок finally (например, если при работе с файлом возникает исключение, то в блоке finally можно прописать закрытие файла):

```kotlin
try{
    val x : Int = 0
    val z : Int = 0 / x
    println("z = $z")
}
catch(e: Exception) {
    println("Exception")
    println(e.message)
}
finally{
    println("Program has been finished")
}
```

В этом случае консольный вывод будет выглядеть следующим образом:

```

```

### Обработка нескольких исключений

Одна программа, один код может генерировать сразу несколько исключений. Для обработки каждого отдельного типа исключений можно определить отдельный блок catch. Например, при одном исключении мы хотим производить одни действия, при другом - другие.

```kotlin
try {
    val nums = arrayOf(1, 2, 3, 4)
    println(nums[6])
}
catch(e:ArrayIndexOutOfBoundsException) {
    println("Out of bound of array")
}
catch (e: Exception) {
    println(e.message)
}
```

В данном случае при доступе по недействительному индексу в массиве будет генерироваться исключение типа ArrayIndexOutOfBoundsException. С помощью блока `catch(e:ArrayIndexOutOfBoundsException)`. Если в программе будут другие исключения, которые не представляют тип ArrayIndexOutOfBoundsException, то они будут обрабатываться вторым блоком catch, так как Exception - это общий тип, который подходит под все типы исключений. При этом стоит отметить, что в начале обрабатывается исключение более частного типа - ArrayIndexOutOfBoundsException, и только потом - более общего типа Exception.

### Оператор throw

Возможно, в каких-то ситуациях мы вручную захотим генерировать исключение. Например, при вычислении факториала мы можем выбрасывать исключение, если передаваемое число, для которого нужно найти факториал, меньше 1. Для генерации исключения применяется оператор **throw**, после которого указывается объект исключения:

```kotlin
fun main(args: Array<String>) {

   try{
       println(factorial(-5))
   }
   catch(e: Exception) {
       println(e.message)
   }
}

fun factorial(n: Int): Int{
    if (n < 1) throw  Exception("Input number must be more than zero")
    var result = 1
    for (i in 1..n)
        result *= i
    return result
}
```

После оператора **throw** указан объект исключения. Для определения объекта Exception применяется конструктор, который принимает в качестве параметра сообщение об исключении. В данном случае это сообщение о том, что число должно быть больше нуля.

И если при вызове функции factorial в нее будет передано число меньше 1, то будет сгенерировано исключение.

### Возвращение значения

Конструкция может возвращать значение. Например:

```kotlin
fun main(args: Array<String>) {

    val a: Int? = try { factorial(5) } catch (e: Exception) { null }

   println(a)
}

fun factorial(n: Int): Int{
    if (n < 1) throw  Exception("Input number must be more than zero")
    var result = 1
    for (i in 1..n)
        result *= i
    return result
}
```

В данном случае переменная a получает в качестве значения факториал числа, передаваемого в функцию factorial. Если же произойдет исключение, тогда переменная a получает то значение, которое указано в блоке catch, то есть в данном случае значение null.


> Материал взят с сайта metanit.com