## Преобразование типов

Нередко может возникать задача по преобразованию типов, например, чтобы использовать данные одного типа в констексте, где требуются данные другого типа. В этом случае Kotlin представляет ряд возможностей по преобразованию типов.

### Встроенные методы преобразования типов

Для преобразования данных одного типа в другой можно использовать встроенные следующие функции, которые есть у базовых типов (Int, Long, Double и т.д.):

- **toByte**

- **toShort**

- **toInt**

- **toLong**

- **toFloat**

- **toDouble**

- **toChar**

Все эти функции преобразуют данные в тот тип, которые идет после префикса to: to**Byte**.

```kotlin
val s: String = "12"
val d: Int = s.toInt()
println(d)
```

В данном случае строка s преобразуется в число d. Просто так передать строку переменной типа Int, мы не можем, несмотря на то, что вроде бы строка и содержит число 12:

```kotlin
val d: Int = "12"    // ! Ошибка
```

Однако надо учитывать, что значение не всегда может быть преобразовано к определенному типу. И в этом случае генерируется исключение. Соответственно в таких случаях желательно отлавливать исключение:

```kotlin
val s: String = "tom"
try {
    val d: Int = s.toInt()
    println(d)
}
catch(e: NumberFormatException) {
    println(e.message)
}
```

### Smart cast и оператор is

Оператор **is** позволяет проверить выражение на принадлежность определенному типу данных. Если локальная переменная или свойство успешно пройдет проверку на принадлежность определенному типу, то далее нет нужды дополнительно приводить значение к этому типу. Данные преобразования еще называются **smart casts** или "умные преобразования".

```kotlin
fun main(args: Array<String>) {

    square(5)
}

fun square(d: Any) {
    //val t = d * d   // недопустимая операция - d - не число, а объект типа Any
    if (d is Int)
        println(d * d)  // норм, d уже представляет тип Int
    else
        println("d is not an Int")
}
```

Здесь в функции double значение параметра d с помощью оператора is проверяется на принадлежность типу Int. Если оно представляет число, то на консоль выводится квадрат этого числа. Причем даже если значение представляет число, как в данном случае, то до применения оператора is оно тем не менее принадлежит типу Any. И только применение оператора is преобразует значение из типа Any в тип Int. Соответственно умножение числа производится без ошибок.

### Явные преобразования и оператор as

Также мы можем явным образом приводить значение одного типа к другому с помощью оператора **as**:

```kotlin
fun main(args: Array<String>) {

    square(5)
}

fun square(d: Any) {
    val t = d as Int    // приводим к типу Int
    println(t * t)
}
```

Однако в случае если преобразование завершится неудачно, то будет сгенерировано исключение **ClassCastException**. Чтобы избежать выброса исключения, мы можем применять более безопасную версию оператора **as?**, которая в случае неудачи преобразования возвращает null.

```kotlin
val name : String  = "Tom"
val id: Int? = name as? Int
println(id)        // null
```

В данном случае оператор `as?` возвратит null, так как строку нельзя преобразовать в число.


> Материал взят с сайта metanit.com