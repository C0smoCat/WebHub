## Абстрактные классы и методы

Абстрактные классы - это классы, определенные с модификатором **abstract**. Отличительной особенностью абстрактных классов является то, что мы не можем создать объект подобного класса. Например, определим абстрактный класс Human:

```kotlin
abstract class Human(val name: String)
```

Абстрактный класс, как и обычный, может иметь свойства, функции, конструкторы, но создать его объект напрямую вызвав его конструктор мы не можем:

```kotlin
val kate: Human        // норм, просто определение переменной
val alice: Human = Human("Alice")    // ! ошибка, создать объект нельзя
```

Такой класс мы можем только унаследовать:

```kotlin
abstract class Human(val name: String) {

    fun hello() {
        println("My name is $name")
    }
}
class Person(name: String): Human(name)
```

Стоит отметить, что в данном случае перед абстрактным классом не надо указывать аннотацию **open**, как при наследовании неабстрактных классов.

```kotlin
fun main(args: Array<String>) {

    val kate: Person = Person("Kate")
    val slim: Human = Person("Slim Shady")
    kate.hello()    // My name is Kate
    slim.hello()    // My name is Slim Shady
}
```

Абстрактные классы могут иметь абстрактные методы. Это такие функции, которые определяются с ключевым словом **abstract** и не содержат реализацию, то есть у них нет тела. При этом абстрактные методы можно определить только в абстрактных классах:

```kotlin
abstract class Human(val name: String) {

    abstract fun hello()
}
class Person(name: String): Human(name) {

    override fun hello() {
        println("My name is $name")
    }
}
```

Если класс наследуется от абстрактного класса, то он должен реализовать все его абстрактные методы. Так, в данном случае класс Person должен обязательно определить реализацию для функции hello. При этом, как и при переопределении обычных методов, применяется аннотация **override**.

Зачем нужны абстрактные классы? Классы обычно отражают какие-то сущности реального мира. Но некоторые из этих сущностей представляют абстракцию, которая непосредственного воплощения не имеет. Например, возьмем систему геометрических фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами. В этом случае мы можем определить абстрактный класс фигуры и затем от него унаследовать все остальные классы фигур:

```kotlin
// абстрактный класс фигуры
abstract class Figure {
    // абстрактный метод для получения периметра
    abstract fun perimeter(): Float

    // абстрактный метод для получения площади
    abstract fun area(): Float
}
// производный класс прямоугольника
class Rectangle(val width: Float, val height: Float) : Figure()
{
    // переопределение получения периметра
    override fun perimeter(): Float{
        return width * 2 + height * 2;
    }
    // переопрелеление получения площади
    override fun area(): Float{
        return width * height;
    }
}
```


> Материал взят с сайта metanit.com