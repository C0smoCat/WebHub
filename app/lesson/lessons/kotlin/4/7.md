## Вложенные классы

В Kotlin классы могут быть определены в других классах. Такие классы (вложенные классы или nested classes) обычно выполняют какую-то вспомогательную роль, а определение их внутри класса позволяет разместить их как можно ближе к тому месту, где они непосредственно используются.

Например, в следующем случае определяется вложенный класс:

```kotlin
class Account{
    class Transaction{

    }
}
```

В данном случае класс Transaction является вложенным, а класс Account - внешним.

По умолчанию вложенные классы имеют модификатор видимости public, то есть они видимы в любой части программы. Но для обращения к вложенному классу надо использовать имя внешнего класса. Например, создание объекта вложенного класса:

```kotlin
val t = Account.Transaction()
```

Если необходимо ограничить область применения вложенного класса только внешним классом, то следует определить вложенный класс с модификатором private:

```kotlin
class Account{
    private class Transaction{

    }
}
```

### Внутренние классы

Стоит учитывать, что вложенный класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. Например, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:

```kotlin
class Account{
    private var sum: Int = 3450
    class Transaction{
        fun pay(s: Int) {
            sum -= s        // ! Ошибка
        }
    }
}
```

Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего класса, необходимо определить вложенный класс с ключевым словом **inner**. Такой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов. Например:

```kotlin
fun main(args: Array<String>) {

    Account().Transaction().pay(1200)
}
class Account{

    private var sum: Int = 3450
    fun display() {
        println("sum = $sum")
    }
    
    inner class Transaction{
        fun pay(s: Int) {
            sum -= s
            display()
        }
    }
}
```

Теперь класс Transaction определен с ключевым словом inner, поэтому имеет полный доступ к свойствам и функциям внешнего класса Account. Но теперь если мы хотим использовать объект подобного вложенного класса, то необходимо создать объект внешнего класса:

```kotlin
Account().Transaction().pay(1200)
```

### Совпадение имен

Но что если свойства и функции внутреннего класса называются также, как и свойства и функции внешнего класса? В этом случае внутренний класс может обратиться к свойствам и функциям внешнего через конструкцию `this@название_класса.имя_свойства_или_функции`:

```kotlin
class A{
    private val n: Int = 1
    inner class B{
        private val n: Int = 1
        fun action() {
            println(n)            // n из класса B
            println(this.n)        // n из класса B
            println(this@B.n)    // n из класса B
            println(this@A.n)    // n из класса A
        }
    }
}
```

Например, перепишем случай выше с классами Account и Transaction следующим образом:

```kotlin
fun main(args: Array<String>) {

    Account().Transaction(1200).pay()
}
class Account{
    private var sum: Int = 3450
    fun display() {
        println("sum = $sum")
    }
    inner class Transaction(s: Int) {
        private var sum : Int = 0
        init {
            this.sum = s
        }
        fun pay() {
            this@Account.sum -= this@Transaction.sum
            display()
        }
    }
}
```


> Материал взят с сайта metanit.com