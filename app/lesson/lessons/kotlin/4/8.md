## Интерфейсы

Интерфейсы представляют контракт, который должен реализовать класс. Интерфейсы могут содержать объявления свойств и функций, а также их реализацию по умолчанию.

Для определения интерфейса применяется ключевое слово **interface**. Например:

```kotlin
interface Movable{
    fun move()      // определение функции без реализации
    fun stop() {     // определение функции с реализацией по умолчанию
        println("Остановка")
    }
}
```

Интерфейс содержит две функции. Функция `move()` представляет абстрактный метод - она не имеет реализации. Вторая функция stop имеет реализацию по умолчанию.

Мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет контракт, которому класс, реализующиий этот интерфейс, должен соответствовать.

Определим два класса, которые применяют интерфейс:

```kotlin
class Car : Movable{

    override fun move() {
        println("Машина едет")
    }
}
class Aircraft : Movable{
    override fun move() {
        println("Самолет летит")
    }
    override fun stop() {
        println("Приземление")
    }
}
```

Для применения интерфейса после имени класса ставится двоеточие, за которым следует название интерфейса. При применении интерфейса класс должен реализовать все его абстрактные методы и свойства, а также может предоставить свою реализацию для тех свойств и методов, которые уже имеют реализацию по умолчанию.

Например, в данном случае интерфейс Movable представляет функцонал транспортного средства и определяет функции move (движение) и stop (остановка).

Класс Car представляет машину и применяет интерфейс Movable. Так как и интерфейс содержит абстрактный метод move, то класс Car обязательно должен его реализовать. Функцию stop класс Car может не реализовать, так как она уже содержит реализацию по умолчанию. При реализации функций перед ними ставится ключевое слово **override**.

Класс Aircraft представляет самолет и тоже применяет интерфейс Movable. При этом класс Aircraft реализует обе функции интерфейса.

Впоследствии в программе мы можем рассматривать объекты классом Car и Aircraft как объекты Movable:

```kotlin
fun main(args: Array<String>) {

    val m1: Movable = Car()
    val m2: Movable = Aircraft()
    // val m3: Movable = Movable() напрямую объект интерфейса создать нельзя
    
    m1.move()
    m1.stop()
    m2.move()
    m2.stop()
}
```

Консольный вывод программы:

```

```

Рассмотрим еще пример. Определим интерфейс Info, который объявляет ряд свойств:

```kotlin
interface Info{
    val model: String
        get() = "Undefined"
    val number: String
}
```

Первое свойство имеет геттер, а это значит, что оно имеет реализацию по умолчанию. При применеии интерфейса такое свойство необязательно реализовать. Второе свойство - number является абстрактным, оно не имеет ни геттера, ни сеттера, то есть не имеет реализации по умолчанию, поэтому классы его обязаны реализовать.

Для реализации интерфейса возьмем выше определенный класс Car:

```kotlin
class Car(mod: String, num: String) : Movable, Info{

    override val number: String
    override val model: String
    init{
        number = num
        model = mod
    }
    override fun move() {
        println("Машина едет")
    }
}
```

Теперь класс Car применяет два интерфейса. Класс может применять несколько интерфейсов, в этом случае они указываются через запятую, и все эти интерфейсы класс должен реализовать. Класс Car реализует оба свойства. При этом при реализации свойств в классе необязательно указывать геттер или сеттер.

Применение класса:

```kotlin
fun main(args: Array<String>) {

    val m1: Car = Car("Tesla", "2345SDG")
    println(m1.model)
    println(m1.number)

    m1.move()
    m1.stop()
}
```


> Материал взят с сайта metanit.com