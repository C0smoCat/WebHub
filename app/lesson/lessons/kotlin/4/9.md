## Наследование

Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это базовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И производный класс (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.

Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию **open**. По умолчанию без этой аннотации класс не может быть унаследован.

```kotlin
open class Person(val name: String)
class Employee(name: String) : Person(name)
```

Например, в данном случае класс Person представляет человека, а класс Employee - работника. Класс Person через первичный конструктор устанавливает свойство name. Каждый работник является человеком, поэтому чтобы не дублировать в классе Employee функциональность класса Person просто наследуем ее.

Для определения производного класса после его имени ставится двоеточие, после которого идет название базового класса. То есть в данном случае класс Person является базовым или суперклассом, а класс Employee - производным классом или классом-наследником.

При наследовании необходимо инициализировать базовый класс. Если производный класс имеет первичный конструктор, то вместе с ним должен вызываться конструктор базового класса.

```kotlin
open class Person(val name: String)
class Employee(val company: String, name: String): Person(name)
```

Если производный класс не имеет никаких конструкторов, то также после двоеточия идет вызов конструктора базового класса:

```kotlin
open class Person()
class Employee: Person()
```

Если производный класс не имеет явного первичного конструктора, тогда при вызове вторичного конструктора должен вызываться конструктор базового класса через ключевое слово **super**:

```kotlin
open class Person(val name: String)
class Employee: Person{

    var company: String="undefined"

    constructor(name: String, comp:String) : super(name) {
        company = comp
    }
}
```

Вызов `super(_name)` представляет вызов конструктора базового класса, которому передается значение параметра _name.

Применение классов:

```kotlin
fun main(args: Array<String>) {

    val alice: Person = Person("Alice")
    val kate: Employee = Employee("Kate", "Google")
    val liza: Person = Employee("Liza", "Apple")
}

open class Person(val name: String)
class Employee: Person{

    var company: String="undefined"

    constructor(name: String, comp:String) : super(name) {
        company = comp
    }
}
```

Причем поскольку объект Employee в то же время является и объектом класса Person в силу отношения наследования, то мы можем переменной типа Person передать объект Employee:

```kotlin
val liza: Person = Employee("Liza", "Apple")
```

Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается.

Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any. Поэтому все классы по умолчанию уже будут иметь такие функции как equals, toString, hashcode.


> Материал взят с сайта metanit.com