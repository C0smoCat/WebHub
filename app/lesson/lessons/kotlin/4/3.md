## Конструкторы

Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. Для определения конструкторов применяется ключевое слово **constructor**.

Классы в Kotlin могут иметь один **первичный конструктор** (primary constructor) и один или несколько **вторичных конструкторов** (secondary constructor).

### Первичный конструктор

Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:

```kotlin
class Person constructor(_name: String) {
   
}
```

Конструкторы, как и обычные функции, могут иметь параметры. Так, в данном случае конструктор имеет параметр `_name`, который представляет тип String. Через параметры конструктора мы можем передать извне данные и использовать их для инициализации объекта. При этом первичный конструктор в отличие от функций не определяет никаких действий, он только может принимать данные извне через параметры.

Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, как в данном случае, то ключевое слово `constructor` можно опустить:

```kotlin
class Person(_name: String) {
   
}
```

### Инициализатор

Что делать с полученными через конструктор данными? Мы их можем использовать для инициализации свойств класса. Для этого применяются блоки инициализаторов:

```kotlin
class Person(_name: String) {
    val name: String
    init{
        name = _name
    }
}
```

В классе Person определено свойство name, которое хранит имя человека. Чтобы передать эту свойству значение параметра `_name` из первичного конструктора, применяется блок инициализатора. Блок инициализатора определяется после ключевого слова **init**.

Цель инициализатора состоит в инициализации объекта при его создании. В классе может быть определено одновременно несколько блоков инициализатора.

Теперь мы можем использовать первичный конструктор класса для создания объекта:

```kotlin
fun main(args: Array<String>) {
    val tom: Person = Person("Tom")
    val bob: Person = Person("Bob")
    val alice: Person = Person("Alice")
    
    println(tom.name)   // Tom
    println(bob.name)   // Bob
    println(alice.name) // Alice
}

class Person(_name: String) {
    val name: String
    init{
        name = _name
    }
}
```

Важно учитывать, что если мы определили первичный конструктор, то мы не можем использовать конструктор по умолчанию, который генерируется компилятором. Для создания объекта обязательно надо использовать первичный конструктор, если он определен в классе.

### Первичный конструктор и свойства

Первичный конструктор также может использоваться для определения свойств:

```kotlin
fun main(args: Array<String>) {

    val bob: Person = Person("Bob", 23)

    println("Name: ${bob.name}  Age: ${bob.age}")
}

class Person(val name: String, val age: Int) {

}
```

Свойства определяются как и параметры, при этом их определение начинается с ключевого слова **val**. И в этом случае нам уже необязательно явным образом определять эти свойства в теле класса, так как их уже определяет конструктор. И при вызове конструктора этим свойствам автоматически передаются значения: `Person("Bob", 23)`

### Вторичные конструкторы

Класс также может определять вторичные конструкторы. Они применяются в основном, чтобы определить дополнительные параметры, через которые можно передавать данные для инициализации объекта.

Вторичные конструкторы определяются в теле класса. Если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова **this**:

```kotlin
class Person(_name: String) {
    val name: String
    var age: Int = 0
    init{
        name = _name
    }
    constructor(_name: String, _age: Int) : this(_name) {
        age = _age
    }
}
```

Здесь в класс Person добавлено свойство age, которое хранит возраст человека. И также добавлен вторичный конструктор. Он принимает два параметра: _name и _age. С помощью ключевого слова this вызывается первичный конструктор, поэтому через этот вызов необходимо передать значения для параметров первичного конструктора. В частности, в первичный конструктор передается значение параметра _name. В самом вторичном конструкторе устанавливается значение свойства age.

Таким образом, при вызове вторичного конструктора вначале вызывается первичный конструктор, срабатывает блок инициализатора, который устанавливает свойство name. Затем выполняются собственно действия вторичного конструктора, который устанавливает свойство age.

Используем данную модификацию класса Person:

```kotlin
fun main(args: Array<String>) {

    val tom: Person = Person("Tom")
    val bob: Person = Person("Bob", 45)
    
    println("Name: ${tom.name}  Age: ${tom.age}")
    println("Name: ${bob.name}  Age: ${bob.age}")
}

class Person(_name: String) {
    val name: String
    var age: Int = 0
    init{
        name = _name
    }
    constructor(_name: String, _age: Int) : this(_name) {
        age = _age
    }
}
```

В функции main создаются два объекта Person. Для создания объекта tom применяется первичный конструктор, который принимает один параметр. Для создания объекта bob применяется вторичный конструктор с двумя параметрами.

Консольный вывод программы:

```

```


> Материал взят с сайта metanit.com