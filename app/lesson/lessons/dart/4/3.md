## Наследование

Наследование является одним из ключевых моментов объектно-ориентированного программирования, позволяя передавать одним классам функционал других. В языке Dart наследование реализуется с помощью ключевого слова **extends** (как в Java):

```dart
void main () {
    
    Employee bob = Employee();
    bob.name = "Bob";
    bob.display();
} 

class Person{
 
    String name;
     
    void display() {
        print("Name: $name");
    }
}
class Employee extends Person{

}
```

Класс Employee, который представляет работника, является подклассом или наследуется от класса Person. А класс Person называется родительским или базовым классом. При наследовании класс Employee перенимает весь функционал класса Person - все его поля и методы и может их использовать. И также можно определить в подклассе новые поля и методы, которых нет в классе Person.

В итоге мы можем создать объект Employee и обращаться к его полю name и методу display, хотя они определены в родительском классе Person.

### Конструкторы и ключевое слово super

В отличие от полей и методов конструкторы базового класса не наследуются. Если базовый класс определяет конструктор, то его необходимо вызвать в классе-наследнике при определение конструктора:

```dart
void main () {
    
    Employee bob = Employee("Bob");
    bob.display();
} 

class Person{
 
    String name;
    Person(this.name);
     
    void display() {
        print("Name: $name");
    }
}
class Employee extends Person{

    Employee(name) : super(name);
}
```

Здесь базовый класс Person определяет конструктор, который принимает один параметр. В производном классе Employee также определяется конструктор, который вызывает конструктор базового класса, передавая ему значение параметра name. Для обращения к функциональности базового класса из производного применяется ключевое слово **super**. В частности, вызов `super(name)` фактически будет представлять обращение к конструктору базового класса `Person(name)`.

Если мы не вызове конструктор базового класса при определении конструктора в производном классе, то мы столкнемся с ошибкой.

### Переопределение методов

Производные классы могут определять свои поля и методы, но также могут переопределять, изменять поведение методов базового класса. Для этого применяется аннотация **@override**:

```dart
void main () {
    
    Employee bob = Employee("Bob", "Google");
    bob.display();
} 

class Person{
 
    String name;
    Person(this.name);
     
    void display() {
        print("Name: $name");
    }
}
class Employee extends Person{

    String company;
    
    Employee(name, this.company) : super(name);
    
    @override
    void display() {
        print("Name: $name");
        print("Company: $company");
    }
}
```

Здесь в класс Employee добавляется еще одно поле - company для хранения места работы сотрудника. Чтобы эту информацию вывести на консоль, переопределяется метод display. В итоге при выполнении программы мы получим следующий консольный вывод:

```

```

Однако мы видим, что часть кода метода display в Employee повторяет код метода display из Person. Чтобы не повторяться, с помощью ключевого слова **super** мы можем просто вызвать реализацию метода display из базового класса:

```dart
@override
void display() {
    super.display();    // Вызов реализации из класса Person
    print("Company: $company");
}
```


> Материал взят с сайта metanit.com