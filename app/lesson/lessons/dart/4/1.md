# Объектно-ориентированное программирование

## Классы и объекты

Dart является объектно-ориентированным языком, и каждое значение, которым мы манипулируем в программе на Dart, является объектом.

**Объект** представляет **экземпляр** некоторого класса, а **класс** является шаблоном или описанием объекта. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке - наличие двух рук, двух ног, головы, туловища и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса.

Класс определяется с помощью ключевого слова **сlass**:

```dart
class Person{

}
```

Здесь определен класс Person. После названия класса идут фигурные скобки, между которыми помещается тело класса - то есть его поля и методы.

Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект.

Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта в классе применяются методы. Например, класс Person, который представляет человека, мог бы иметь следующее определение:

```dart
class Person{
    
    String name;        // имя
    int age;            // возраст
    void display() {
        print("Name: $name Age: $age");
    }
}
```

В классе Person определены два поля: name представляет имя человека, а age - его возраст. И также определен метод display, который ничего не возвращает и просто выводит эти данные на консоль.

Теперь используем данный класс. Для этого определим следующую программу:

```dart
void main() {
        
    Person tom;
}
class Person{
    
    String name;    // имя
    int age;        // возраст
    void display() {
        print("Name: $name Age: $age");
    }
}
```

Класс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип. Так, здесь в функции main определена переменная `tom`, которая представляет класс Person. Но пока эта переменная не указывает ни на какой объект и по умолчанию она имеет значение **null**. По большому счету мы ее пока не можем использовать, поэтому вначале необходимо создать объект класса Person.

### Конструкторы

Кроме обычных методов классы могут определять специальные методы, которые называются **конструкторами**. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.

Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров.

Выше определенный класс Person не имеет никаких конструкторов. Поэтому для него автоматически создается конструктор по умолчанию, который мы можем использовать для создания объекта Person. В частности, создадим один объект:

```dart
void main () {
    
    Person tom = Person();
    tom.display();
    // изменяем имя и возраст
    tom.name = "Tom";
    tom.age = 35;
    tom.display();
} 

class Person{

    String name;        // имя
    int age;            // возраст
    void display() {
        print("Name: $name Age: $age");
    }
}
```

Для создания объекта Person используется выражение `Person()`. Более старые версии Dart для вызова конструктора также использовали оператор **new**: `Person tom = new Person();`. Но в последних версиях Dart оператор `new` можно не использовать.

Конструктор по умолчанию не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная `tom` получит ссылку на созданный объект.

Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию, то есть значение **null** (то есть фактически отсутствие значения).

После создания объекта мы можем обратиться к переменным и методам объекта Person через переменную tom. Для этого используется оператор точка (.) - то есть через точку указываем название поля или метода: `tom.name`. Например, можно установить или получить значения полей: `tom.name = "Tom"`.

В итоге мы увидим на консоли:

```

```

Если необходимо, что при создании объекта производилась какая-то логика, например, чтобы поля класса получали какие-то определенные значения, то можно определить в классе свои конструкторы. Например:

```dart
void main () {
    
    Person sam = Person("Sam", 25);
    sam.display();
} 

class Person{

    String name;        // имя
    int age;            // возраст
    
    Person(String n, int a)
    {
        name = n;
        age = a;
    }
    void display() {
        print("Name: $name Age: $age");
    }
}
```

Теперь в классе определен коструктор, который принимает два параметра и с их помощью устанавливает значения полей объекта.

Консольный вывод программы:

```

```

Следует учитывать, что если мы определяем в классе свои конструкторы, как в случае выше, то конструктор по умолчанию мы уже использовать не сможем.

### Именованные конструкторы

По умолчанию мы можем определить только один общий конструктор. Если же нам необходимо использовать в классе сразу несколько конструкторов, то в этом случае нужно применять **именованные конструкторы** (named constructors). Например:

```dart
void main () {
    
    Person bob = Person.undefined();      // вызов первого конструктора без параметров
    bob.display();
         
    Person tom = Person.fromName("Tom"); // вызов второго конструктора с одним параметром
    tom.display();
         
    Person sam = Person("Sam", 25); // вызов третьего конструктора с двумя параметрами
    sam.display();
} 

class Person{

    String name;        // имя
    int age;            // возраст
    
    Person.undefined() {
        name = "undefined";
        age = 18;
    }
    Person.fromName(String n) {
        name = n;
        age = 18;
    }
    Person(String n, int a)
    {
        name = n;
        age = a;
    }
    void display() {
        print("Name: $name Age: $age");
    }
}
```

В данном случае определено два дополнительных конструктора: Person.undefined без параметров и Person.fromName с одним параметров. При вызове подобных конструкторов необходимо указывать их полное имя: `Person tom = Person.fromName("Tom");`

Консольный вывод программы:

```

```

### Ключевое слово this

Ключевое слово **this** представляет ссылку на текущий экземпляр класса. Через эо ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы. Например:

```dart
class Person{

    String name; 
    int age; 
    
    Person(String name, int age)
    {
        this.name = name;
        this.age = age;
    }
    void display() {
        print("Name: $name Age: $age");
    }
}
```

В конс��рукторе параметры называются так же, как и поля класса. И чтобы разграничить поля и параметры, применяется ключевое слово this:

```dart
this.name = name;
```

Так, в данном случае указываем, что значение параметра name присваивается полю name.

Также используя ключевое слово this, мы можем сократить определение конструктора:

```dart
class Person{

    String name;        // имя
    int age;            // возраст
    
    Person(this.name, this.age);
    
    void display() {
        print("Name: $name Age: $age");
    }
}
```

Когда будет происходить вызов конструктора:

```dart
Person sam = Person("Sam", 25);
```

То строка "Sam" будет передаваться this.name, а число 25 - this.age.

### Вызов цепочки конструкторов

В примере с именованными конструкторами выше применялось три конструктора, которые выполняют идентичные действия: устанавливают поля name и age. Чтобы избежать повторов, с помощью this можно вызвать один из конструкторов класса и передать для его параметров необходимые значения. В итоге мы сможем определить несколько конструкторов, которые принимают разное количество параметров и по цепочке вызывают друг друга:

```dart
void main () {
    
    Person bob = Person.undefined();      // вызов первого конструктора без параметров
    bob.display();
         
    Person tom = Person.fromName("Tom"); // вызов второго конструктора с одним параметром
    tom.display();
         
    Person sam = Person("Sam", 25); // вызов третьего конструктора с двумя параметрами
    sam.display();
} 

class Person{

    String name;
    int age;
    Person.undefined(): this("undefined", 18);
    
    Person.fromName(String name): this(name, 18);
    
    Person(this.name, this.age);
    
    void display() {
        print("Name: $name Age: $age");
    }
}
```

В данном случае первый и второй конструктор вызывают третий, в котором собственно будут устанавливаться поля name и age.

### Инициализаторы

Инициализаторы представляют способ инициализации полей класса:

```dart
void main () {
    
    Person tom = Person("Tom", 23);
    tom.display();
} 

class Person{
 
    String name;
    int age;
     
    Person(userName, userAge) : name=userName, age = userAge 
    {
        print("Person ctor!");
    }
     
    void display() {
        print("Name: $name Age: $age");
    }
}
```

Список инициализации указывает после параметров конструктора через двоеточие до открывающей фигурной скобки:

```dart
Person(userName, userAge) : name=userName, age = userAge {
```

Обычно списки инициализации используют параметры конструктора для установки значений полей. При этом конструктор может выполнять какую-то другую работу.

При этом при инициализации полей можно задать какую-нибудь динамическую логику:

```dart
Person(userName, userAge) : name=userName, age = userAge + 10 {
    print("Person ctor!");
}
```

Стоит учитывать, что при использовании инициализаторов сначала выполняется инициализация полей в списках инициализации и только затем выполняется логика в конструкторе:

```dart
Person(userName, userAge) : name=userName, age = userAge + 10 {
    age = 8;
}
```

В данном случае значение поля age будет равно 8, так как констуктор перезапишет значение, установленое инициализатором.


> Материал взят с сайта metanit.com