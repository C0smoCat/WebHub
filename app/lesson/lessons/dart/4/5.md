## Реализация интерфейсов

Наследование в языке Dart имеет важное ограничение: мы не можем наследовать класс сразу от нескольких классов, например, следующим образом:

```dart
class Person{
 
    String name;
    void display() { 
        print("Name: $name");
    }
}
class Worker{
    String company;
    void work() {
        print("Work in $company");
    }
}
class Employee extends Person, Worker{ // Ошибка, множественное наследование не допускается
}
```

Для решения этой проблемы в Dart применяется реализация интерфейсов. При этом важно понимать, что интерфейс - это не отдельная сущность, как в некоторых языках программирования (например, тип interface в C# или Java), а тот же класс. То есть класс в Dart одновременно выступает в роли интерфейса, и другой класс может реализовать данный интерфейс.

Для реализации интерфейсов применяется оператор **implements**:

```dart
void main () {
    
    Person bob = Employee();
    bob.name = "Bob";
    bob.display();    // Employee name: Bob
} 

class Person{
 
    String name;
    Person(this.name);
     
    void display() {
        print("Name: $name");
    }
}

class Employee implements Person{

    String name;            // реализация поля name
    // реализация метода display
    void display() {        
        print("Employee name: $name");
    }
}
```

В данном случае класс Employee применяет интерфейс класса Person (`Employee implements Person`). Применение интерфейса класса Person означает, что класс Employee должен реализовать все поля и методы, которые определены в классе Person. Поэтому класс Employee должен определить поле name и метод display. По сути интерфейс - это контракт, что класс должен содержать определенный функционал (в данном случае поле name и метод display). Если класс Employee не определил бы все поля и методы, которые есть в классе Person, то мы столкнулись бы с ошибкой.

В то же время из приведенного выше примеры видно, что класс Employee не обязан реализовать конструктор и может вообще не определять никакого конструктора.

Подобным образом мы можем реализовать сразу несколько интерфейсов:

```dart
void main () {
    
    Employee bob = Employee("Bob", "Google");
    bob.display();    // Employee name: Bob
    bob.work();        // Employee works in Google
} 

class Person{
 
    String name;
    Person(this.name);
     
    void display() {
        print("Name: $name");
    }
}
class Worker{
    String company;
    void work() {
        print("Work in $company");
    }
}
class Employee implements Person, Worker{

    String name;            // реализация поля name из Person
    String company;            // реализация поля company из Worker
    // реализация метода display Person
    void display() {        
        print("Employee name: $name");
    }
    // реализация метода work из Worker
    void work() {
        print("Employee works in $company");
    }
    
    Employee(this.name, this.company);
}
```

В данном случае класс Employee реализует интерфейс классов Person и Worker.

### Наследование классов vs реализация интерфейсов

При наследовании производный класс не обязан определять те же поля и методы, которые есть в базовом классе (за исключением абстрактных методов). Если базовом классе определяется конструктор, то производный класс обязан определить свой конструктор, при котором вызывается конструктор базового класса. В производном классе мы можем обращаться к реализации базового класса с помощью ключевого слова **super**. Не поддерживается множественное наследование.

При реализации интерфейса производный класс должен определить все поля и методы, которые определены в классе интерфейса. Если в базовом есть конструктор, то производный класс НЕ обязан определять свой конструктор. В производном классе мы НЕ можем. обращаться к реализации базового класса с помощью ключевого слова **super**. Поддерживается множественная реализация интерфейсов.


> Материал взят с сайта metanit.com