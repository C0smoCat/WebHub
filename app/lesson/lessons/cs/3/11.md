## Перегрузка операторов

Наряду с методами мы можем также перегружать операторы. Например, пусть у нас есть следующий класс Counter:

```cs
class Counter
{
    public int Value { get; set; }
}
```

Данный класс представляет некоторый счетчик, значение которого хранится в свойстве Value.

И допустим, у нас есть два объекта класса Counter - два счетчика, которые мы хотим сравнивать или складывать на основании их свойства Value, 
используя стандартные операции сравнения и сложения:

```cs
Counter c1 = new Counter { Value = 23 };
Counter c2 = new Counter { Value = 45 };

bool result = c1 > c2;
Counter c3 = c1 + c2;
```

Но на данный момент ни операция сравнения, ни операция сложения для объектов Counter не доступны. Эти операции могут использоваться 
для ряда примитивных типов. Например, по умолчанию мы можем складывать числовые значения, но как складывать объекты комплексных типов - 
классов и структур компилятор не знает. И для этого нам надо выполнить перегрузку нужных нам операторов.

Перегрузка операторов заключается в определении в классе, для объектов которого мы хотим определить оператор, специального метода:

```cs
public static возвращаемый_тип operator оператор(параметры)
{  }
```

Этот метод должен иметь модификаторы **public static**, так как перегружаемый оператор будет 
использоваться для всех объектов данного класса. Далее идет название возвращаемого типа. Возвращаемый тип представляет тот тип, объекты которого мы хотим получить. 
К примеру, в результате сложения двух объектов Counter мы ожидаем получить новый объект Counter. А в результате сравнения двух мы хотим 
получить объект типа bool, который указывает истинно ли условное выражение или ложно. Но в зависимости от задачи возвращаемые типы могут быть любыми.

Затем вместо названия метода идет ключевое слово **operator** и собственно сам оператор. И далее в скобках перечисляются 
параметры. Бинарные операторы принимают два параметра, унарные - один параметр. И в любом случае один из параметров должен 
представлять тот тип - класс или структуру, в котором определяется оператор.

Например, перегрузим ряд операторов для класса Counter:

```cs
class Counter
{
    public int Value { get; set; }
        
    public static Counter operator +(Counter c1, Counter c2)
    {
        return new Counter { Value = c1.Value + c2.Value };
    }
    public static bool operator >(Counter c1, Counter c2)
    {
        return c1.Value > c2.Value;
    }
    public static bool operator <(Counter c1, Counter c2)
    {
        return c1.Value < c2.Value;
    }
}
```

Поскольку все перегруженные операторы - бинарные - то есть проводятся над двумя объектами, то для каждой перегрузки предусмотрено 
по два параметра.

Так как в случае с операцией сложения мы хотим сложить два объекта класса Counter, то оператор принимает два объекта этого класса. И так как мы хотим в результате сложения 
получить новый объект Counter, то данный класс также используется в качестве возвращаемого типа. Все действия этого оператора сводятся к созданию, нового объекта, свойство Value 
которого объединяет значения свойства Value обоих параметров:

```cs
public static Counter operator +(Counter c1, Counter c2)
{
    return new Counter { Value = c1.Value + c2.Value };
}
```

Также переопределены две операции сравнения. Если мы переопределяем одну из этих операций сравнения, то мы также должны переопределить вторую из этих операций. 
Сами операторы сравнения сравнивают значения свойств Value и в зависимости от результата сравнения возвращают либо true, либо false.

Теперь используем перегруженные операторы в программе:

```cs
static void Main(string[] args)
{
    Counter c1 = new Counter { Value = 23 };
    Counter c2 = new Counter { Value = 45 };
    bool result = c1 > c2;
    Console.WriteLine(result); // false

    Counter c3 = c1 + c2;
    Console.WriteLine(c3.Value);  // 23 + 45 = 68
    
    Console.ReadKey();
}
```

Стоит отметить, что так как по сути определение оператора представляет собой метод, то этот метод мы также можем перегрузить, то есть 
создать для него еще одну версию. Например, добавим в класс Counter еще один оператор:

```cs
public static int operator +(Counter c1, int val)
{
    return c1.Value + val;
}
```

Данный метод складывает значение свойства Value и некоторое число, возвращая их сумму. И также мы можем применить этот оператор:

```cs
Counter c1 = new Counter { Value = 23 };
int d = c1 + 27; // 50
Console.WriteLine(d);
```

Следует учитывать, что при перегрузке не должны изменяться те объекты, которые передаются в оператор через параметры. Например, мы можем определить для класса 
Counter оператор инкремента:

```cs
public static Counter operator ++(Counter c1)
{
    c1.Value += 10;
    return c1;
}
```

Поскольку оператор унарный, он принимает только один параметр - объект того класса, в котором данный оператор определен. Но это 
**неправильное** определение инкремента, так как оператор не должен менять значения своих параметров.

И более корректная перегрузка оператора инкремента будет выглядеть так:

```cs
public static Counter operator ++(Counter c1)
{
    return new Counter { Value = c1.Value + 10 };
}
```

То есть возвращается новый объект, который содержит в свойстве Value инкрементированное значение.

При этом нам не надо определять отдельно операторы для префиксного и для постфиксного инкремента (а также декремента), так как одна реализация 
будет работать в обоих случаях.

Например, используем операцию префиксного инкремента:

```cs
Counter counter = new Counter() { Value = 10 };
Console.WriteLine($"{counter.Value}");      // 10
Console.WriteLine($"{(++counter).Value}");  // 20
Console.WriteLine($"{counter.Value}");      // 20
```

Консольный вывод:

```

```

Теперь используем постфиксный инкремент:

```cs
Counter counter = new Counter() { Value = 10 };
Console.WriteLine($"{counter.Value}");      // 10
Console.WriteLine($"{(counter++).Value}");  // 10
Console.WriteLine($"{counter.Value}");      // 20
```

Консольный вывод:

```

```

Также стоит отметить, что мы можем переопределить операторы **true** и **false**. 
Например, определим их в классе Counter:

```cs
class Counter
{
    public int Value { get; set; }
    
    public static bool operator true(Counter c1)
    {
        return c1.Value != 0;
    }
    public static bool operator false(Counter c1)
    {
        return c1.Value == 0;
    }
    
    // остальное содержимое класса
}
```

Эти операторы перегружаются, когда мы хотим использовать объект типа в качестве условия. Например:

```cs
Counter counter = new Counter() { Value = 0 };
if (counter)
    Console.WriteLine(true);
else
    Console.WriteLine(false);
```

При перегрузке операторов надо учитывать, что не все операторы можно перегрузить. 
В частности, мы можем перегрузить следующие операторы:

- унарные операторы +, -, !, ~, ++, --

- бинарные операторы +, -, *, /, %

- операции сравнения ==, !=, <, >, <=, >=

- логические операторы &&, ||

И есть ряд операторов, которые нельзя перегрузить, например, операцию равенства `=` или тернарный оператор `?:`, а также ряд др��гих.

Полный список перегружаемых операторов можно найти в документации msdn

При перегрузке операторов также следует помнить, что мы не можем изменить приоритет оператора или его ассоциативность, мы не можем создать 
новый оператор или изменить логику операторов в типах, который есть по умолчанию в .NET.

