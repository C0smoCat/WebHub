# Aсинхронное программирование

## Асинхронные методы, async и await

**Асинхронность** позволяет вынести отдельные задачи из основного потока в специальные асинхронные 
методы или блоки кода. Особенно это актуально в графических программах, где продолжительные задачи могу блокировать интерфейс 
пользователя. И чтобы этого не произошло, нужно задействовать асинхронность. Также асинхронность несет выгоды в веб-приложениях при 
обработке запросов от пользователей, при обращении к базам данных или сетевым ресурсам. При больших запросах к базе данных асинхронный 
метод просто уснет на время, пока не получит данные от БД, а основной поток сможет продолжить свою работу. 
В синхронном же приложении, если бы код получения данных находился в основном потоке, этот поток просто бы блокировался на время получения данных.

Ключевыми для работы с асинхронными вызовами в C# являются два ключевых слова: **async** и **await**, 
цель которых - упростить написание асинхронного кода. Они используются вместе для создания асинхронного метода.

**Асинхонный метод** обладает следующими признаками:

- В заголовке метода используется модификатор **async**

- Метод содержит одно или несколько выражений **await**

- В качестве возвращаемого типа используется один из следующих:

Асинхронный метод, как и обычный, может использовать любое количество параметров или не использовать их вообще. Однако асинхронный 
метод не может определять параметры с модификаторами **out** и **ref**.

Также стоит отметить, что слово **async**, которое указывается в определении метода, не делает автоматически метод 
асинхронным. Оно лишь указывает, что данный метод может содержать одно или несколько выражений **await**.

Рассмотрим пример асинхронного метода:

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static void Factorial()
        {
            int result = 1;
            for(int i = 1; i <= 6; i++)
            {
                result *= i;
            }
            Thread.Sleep(8000);
            Console.WriteLine($"Факториал равен {result}");
        }
        // определение асинхронного метода
        static async void FactorialAsync()
        {
            Console.WriteLine("Начало метода FactorialAsync"); // выполняется синхронно
            await Task.Run(()=>Factorial());                // выполняется асинхронно
            Console.WriteLine("Конец метода FactorialAsync");
        }

        static void Main(string[] args)
        {
            FactorialAsync();    // вызов асинхронного метода

            Console.WriteLine("Введите число: ");
            int n = Int32.Parse(Console.ReadLine());
            Console.WriteLine($"Квадрат числа равен {n * n}");
            
            Console.Read();
        }
    }
}
```

Здесь прежде всего определен обычный метод подсчета факториала. Для имитации долгой работы в нем используется задержка на 8 секунд с помощью метода `Thread.Sleep()`. 
Условно это некоторый метод, который выполняет некоторую работу продолжительное время. Но для упрощения понимания он просто подсчитывает факториал числа 6.

Также здесь определен асинхронный метод `FactorialAsync()`. Асинхронным он является потому, что имеет в определении перед возвращаемым типом 
модификатор **async**, его возвращаемым типом является void, и в теле метода определено выражение 
**await**.

Выражение **await** определяет задачу, которая будет выполняться асинхронно. В данном случае 
подобная задача представляет выполнение функции факториала:

```cs
await Task.Run(()=>Factorial());
```

По негласным правилам в названии асинхроннных методов принято использовать суффикс **Async** - `Factorial**Async**()`, хотя в принципе это необязательно делать.

Сам факториал мы получаем в асинхронном методе `FactorialAsync`. Асинхронным он является потому, что он объявлен с модификатором 
`async` и содержит использование ключевого слова `await`.

И в методе Main мы вызываем этот асинхронный метод.

Посмотрим, какой у программы будет консольный вывод:

Разберем поэтапно, что здесь происходит:

Функция факториала, возможно, представляет не самый показательный пример, так как в реальности в данном случае нет смысла делать ее асинхронной. 
Но рассмотрим другой пример - чтение-запись файла:

```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using System.IO;

namespace HelloApp
{
    class Program
    {
        static async void ReadWriteAsync()
        {
            string s = "Hello world! One step at a time";

            // hello.txt - файл, который будет записываться и считываться
            using (StreamWriter writer = new StreamWriter("hello.txt", false))
            {
                await writer.WriteLineAsync(s);  // асинхронная запись в файл
            }
            using (StreamReader reader = new StreamReader("hello.txt"))
            {
                string result = await reader.ReadToEndAsync();  // асинхронное чтение из файла
                Console.WriteLine(result);
            }
        } 
        static void Main(string[] args)
        {
            ReadWriteAsync();
            
            Console.WriteLine("Некоторая работа");
            Console.Read();
        }
    }
}
```

Асинхронный метод `ReadWriteAsync()` выполняет запись в файл некоторой строки и затем считывает записанный файл. Подобные операции могут занимать продолжительное время, 
особенно при больших объемах данных, поэтому такие операции лучше делать асинхронными.

Фреймворк .NET уже имеет встроенную поддержку таких операций. Например, в классе StreamWriter определен метод 
**WriteLineAsync()**. По сути он уже представляет асинхронную операцию и принимает в качестве параметра 
некоторую строку, которую надо записать в файл. Поскольку этот метод представляет асинхронную операцию, то вызов этого метода мы можем 
оформить в выражение **await**:

```cs
await writer.WriteLineAsync(s);  // асинхронная запись в файл
```

Аналогично в классе StreamReader определен метод **ReadToEndAsync()**, который также представляет асинхронную 
операцию и который возвращает весь считанный текст.

Во фреймворке .NET Core определено много подобных методов. Как правило, они связаны с работой с файлами, отправкой сетевых запросов или запросов к базе данных. 
Их легко узнать по суффиксу **Async**. То есть если метод имеет подобный суффикс в названии, то с большей степенью вероятности 
его можно использовать в выражении await.

Далее в методе Main вызывается асинхронный метод ReadWriteAsync:

```cs
static void Main(string[] args)
{
    ReadWriteAsync();
            
    Console.WriteLine("Некоторая работа");
    Console.Read();
}
```

И опять же, когда выполнение в методе ReadWriteAsync доходит до первого выражения await, управление возвращается 
в метод Main, и мы можем продолжать с ним работу. Запись в файл и считывание файла будут производиться параллельно и 
не будут блокировать работу метода Main.

### Определение асинхронной операции

Как выше уже было сказано, фреймворк .NET Core имеет много встроенных методов, которые представляют асинхронную операцию. Они заканчиваются на суффикс Async. 
И перед вызывами подобных методов мы можем указывать оператор **await**. Например:

```cs
StreamWriter writer = new StreamWriter("hello.txt", false);
await writer.WriteLineAsync("Hello");  // асинхронная запись в файл
```

Либо мы сами можем определить асинхронную операцию, используя метод **Task.Run()**:

```cs
static void Factorial()
{
    int result = 1;
    for (int i = 1; i <= 6; i++)
    {
        result *= i;
    }
    Thread.Sleep(8000);
    Console.WriteLine($"Факториал равен {result}");
}
// определение асинхронного метода
static async void FactorialAsync()
{
    await Task.Run(()=>Factorial()); // вызов асинхронной операции
}
```

Можно определить асинхронную операцию с помощью лямбда-выражения:

```cs
static async void FactorialAsync()
{
    await Task.Run(() =>
    {
        int result = 1;
        for (int i = 1; i <= 6; i++)
        {
            result *= i;
        }
        Thread.Sleep(8000);
        Console.WriteLine($"Факториал равен {result}");
    });
}
```

### Передача параметров в асинхронную операцию

Выше вычислялся факториал 6, но, допустим, мы хотим вычислять факториалы разных чисел:

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static void Factorial(int n)
        {
            int result = 1;
            for (int i = 1; i <= n; i++)
            {
                result *= i;
            }
            Thread.Sleep(5000);
            Console.WriteLine($"Факториал равен {result}");
        }
        // определение асинхронного метода
        static async void FactorialAsync(int n)
        {
            await Task.Run(()=>Factorial(n));
        }
        static void Main(string[] args)
        {
            FactorialAsync(5);
            FactorialAsync(6);
            Console.WriteLine("Некоторая работа");
            Console.Read();
        }
    }
}
```

### Получение результата из асинхронной операции

Асинхронная операция может возвращать некоторый результат, получить который мы можем так же, как и при вызове обычного метода:

```cs
using System;
using System.Threading;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static int Factorial(int n)
        {
            int result = 1;
            for (int i = 1; i <= n; i++)
            {
                result *= i;
            }
            return result;
        }
        // определение асинхронного метода
        static async void FactorialAsync(int n)
        {
            int x = await Task.Run(()=>Factorial(n));
            Console.WriteLine($"Факториал равен {x}");
        }
        static void Main(string[] args)
        {
            FactorialAsync(5);
            FactorialAsync(6);
            Console.Read();
        }
    }
}
```

Метод Factorial возвращает значение типа int, это значение мы можем получить, просто присвоив результат асинхронной операции 
переменной данного типа: `int x = await Task.Run(()=>Factorial(n));`

