# Объектно-ориентированное программирование. Практика

## Создание проекта библиотеки классов

В предыдущих главах были рассмотрены основные концепции объектно-ориентированного программирования. В этой главе создадим приложение, в котором на практическом примере применим большую часть этих концепций.

Вначале создадим новый проект консольного приложения .NET Core, который назовем **BankApplication**:

![Создание консольного проекта в Visual Sudio 2019](https://metanit.com/sharp/tutorial/./pics/3.4.png)

![Создание консольного проекта .NET Core в Visual Sudio 2019](https://metanit.com/sharp/tutorial/./pics/3.24.png)

И после этого создается стандартный пустой проект с классом Program и методом Main. Это будет главный проект приложения.

Но для хранения классов и интерфейсов нередко создаются отдельные проекты, в рамках которых все классы компилируются в файл библиотеки dll, которая затем подключается к главному проекту. Поэтому добавим в решение новый проект. Для этого нажмем правой кнопкой мыши на решение и выберем в контекстном меню **Add -> New Project...**:

![Добавление проекта в решение в Visual Studio 2019](https://metanit.com/sharp/tutorial/./pics/3.5.png)

В качестве типа нового проекта выберем шаблон **Class Library (.NET Core)** и назовем новый проект **BankLibrary**:

![Создание библиотеки классов в Visual Studio 2019](https://metanit.com/sharp/tutorial/./pics/3.6.png)

После этого в решение добавляется новый проект, который по умолчанию имеет один файл Class1.cs. Он нам не нужен, поэтому удалим этот файл.

Этот проект будет содержать все классы, которые будут использоваться главным проектом.

Наше приложение будет имитировать работу банка. И прежде чем начать работу над приложением, выделим сущности, которые будем использовать, а также отношения между сущностями. Ну в частности, здесь мы можем выделить такие сущности, как сам банк, банковский счет. Счета бывают различных видов, например, счета до востребования и депозиты, соответственно будет несколько сущностей счетов.

Первым делом добавим в проект BankLibrary новый интерфейс, который будет описывать функциональность банковского счета. При проектировании интерфейса следует помнить, что если он определяет функционал без реализации, то данный функционал обязательно должен быть реализован в классах, применяющих данный интерфейс.

Итак, добавим в проект BankLibrary интерфейс **IAccount**, который будет иметь следующее содержание:

```cs
public interface IAccount
{
    // Положить деньги на счет
    void Put(decimal sum);
    // Взять со счета
    decimal Withdraw(decimal sum);
}
```

Данный интерфейс определяем два метода для того, чтобы положить на счет или вывести средства со счета.

Для реакции на изменения состояния счеты мы будем использовать событийную модель, то есть обрабатываться различные изменения счета через события. Для этого добавим в проект BankLibrary новый файл **AccountStateHandler.cs**, в котором определим делегат и вспомогательный класс:

```cs
namespace BankLibrary
{
    public delegate void AccountStateHandler(object sender, AccountEventArgs e);

    public class AccountEventArgs
    {
        // Сообщение
        public string Message { get; private set;}
        // Сумма, на которую изменился счет
        public decimal Sum { get; private set;}

        public AccountEventArgs(string _mes, decimal _sum)
        {
            Message = _mes;
            Sum = _sum;
        }
    }
}
```

Делегат `AccountStateHandler` будет использоваться для создания событий. А для обработки событий также определен класс `AccountEventArgs`, который определяет два свойства для чтения: сообщение о событии и сумма, на которую изменился счет.

Теперь определим основной класс приложения Account.


> Материал взят с сайта metanit.com