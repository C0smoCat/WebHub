## Ковариантность и контравариантность обобщенных интерфейсов

Понятия ковариантности и контравариантности связаны с возможностью использовать в приложении вместо некоторого типа другой тип, который находится ниже или выше в иерархии наследования.

Имеется три возможных варианта поведения:
- **Ковариантность**: позволяет использовать более конкретный тип, чем заданный изначально
- **Контравариантность**: позволяет использовать более универсальный тип, чем заданный изначально
- **Инвариантность**: позволяет использовать только заданный тип

C# позволяет создавать ковариантные и контравариантные обобщенные интерфейсы. Эта функциональность повышает гибкость при использовании обобщенных интерфейсов в программе. По умолчанию все обобщенные интерфейсы, например, `IAccout<T>` являются инвариантными.

Для рассмотрения ковариантных и контравариантных интерфейсов возьмем следующие классы:

```cs
class Account
{
    public virtual void DoTransfer(int sum)
    {
    Console.WriteLine($"Клиент положил на счет {sum} долларов");
    }
}
class DepositAccount : Account
{
    public override void DoTransfer(int sum)
    {
        Console.WriteLine($"Клиент положил на депозитный счет {sum} долларов");
    }
}
```

Здесь определен класс обычного счета - Account и унаследованный от него класс DepositAccount. В классе Account определен метод, который выполняет условную операцию с счетом. Класс DepositAccount немного переопределяет этот интерфейс.

### Ковариантные интерфейсы

Обобщенные интерфейсы могут быть ковариантными, если к универсальному параметру применяется ключевое слово **out**. Например:

```cs
interface IBank<out T>
{
    T CreateAccount(int sum);
}

class Bank<T> : IBank<T> where T : Account, new()
{
    public T CreateAccount(int sum)
    {
        T acc = new T();  // создаем счет
        acc.DoTransfer(sum);
        return acc;
    }
}
```

Обобщенный интерфейс IBank определяет метод CreateAccount для создания счета. При этом на момент определения интерфейса мы не знаем, какой тип будет представлять счет. Ключевое слово **out** в определении интерфейса указывает, что данный интерфейс будет ковариантным.

Класс Bank, который представляет условный банк, реализует этот интерфейс и возвращает из метода CreateAccount объект, который представляет либо класс Account, либо один из его наследников.

Применим данные типы в программе:

```cs
static void Main(string[] args)
{
    IBank<DepositAccount> depositBank = new Bank<DepositAccount>();
    Account acc1 = depositBank.CreateAccount(34);

    IBank<Account> ordinaryBank = new Bank<DepositAccount>();
    // или так
    // IBank<Account> ordinaryBank = depositBank;
    Account acc2 = ordinaryBank.CreateAccount(45);

    Console.Read();
}
```

То есть мы можем присвоить более общему типу `IBank<Account>` объект более конкретного типа `IBank<DepositAccount>` или `Bank<DepositAccount>`.

В то же время если бы мы не использовали ключевое слово `out`:

```cs
interface IBank<out T>
```

то мы столкнулись бы с ошибкой в строке

```cs
IBank<Account> ordinaryBank = depositBank;
```

Поскольку в этом случае невозможно было бы привести объект `Bank<DepositAccount>` к типу `IBank<Account>`

При создании ковариантного интерфейса надо учитывать, что универсальный параметр может использоваться только в качестве типа значения, возвращаемого методами интерфейса. Но не может использоваться в качестве типа аргументов метода или ограничения методов интерфейса.

### Контравариантные интерфейсы

Для создания контравариантного интерфейса надо использовать ключевое слово **in**. Например, возьмем те же классы Account и DepositAccount и определим следующие типы:

```cs
interface ITransaction<in T>
{
    void DoOperation(T account, int sum);
}

class Transaction<T> : ITransaction<T> where T : Account
{
    public void DoOperation(T account, int sum)
    {
        account.DoTransfer(sum);
    }
}
```

Здесь определен интерфейс ITransaction, который представляет условную банковскую операцию. Ключевое слово **in** в определении интерфейса указывает, что этот интерфейс - контравариантный. Интерфейс определяет метод DoOperation, который принимает некоторый счет и выполняет с ним операцию.

Класс Transaction реализует этот интерфейс и реализует его метод DoOperation.

Применим эти типы в программе:

```cs
static void Main(string[] args)
{
    ITransaction<Account> accTransaction = new Transaction<Account>();
    accTransaction.DoOperation(new Account(), 400);

    ITransaction<DepositAccount> depAccTransaction = new Transaction<Account>();
    depAccTransaction.DoOperation(new DepositAccount(), 450);

    Console.Read();
}
```

Так как интерфейс ITransaction использует универсальный параметр с ключевым словом `in`, то он является контравариантным, поэтому в коде мы можем объект `Transaction<Account>` привести к типу `ITransaction<DepositAccount>`:

```cs
ITransaction<DepositAccount> depAccTransaction = new Transaction<Account>();
```

Если бы ключевое слово **in** не использовалось бы, то мы не смогли бы выполнить подобное приведение. То есть объект интерфейса с более универсальным типом приводится к объекту интерфейса с более конкретным типом.

При создании контрвариантного интерфейса надо учитывать, что универсальный параметр контрвариантного типа может применяться только к аргументам метода, но не может применяться к аргументам, используемым в качестве возвращаемых типов.


> Материал взят с сайта metanit.com