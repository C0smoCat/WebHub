## Наследование интерфейсов

Интерфейсы, как и классы, могут наследоваться:

```cs
interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    void Run();
}
class BaseAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("Move");
    }
    public void Run()
    {
        Console.WriteLine("Run");
    }
}
```

При применении этого интерфейса класс BaseAction должен будет реализовать как методы и свойства интерфейса IRunAction, так и методы и 
свойства базового интерфейса IAction, если эти методы и свойства не имеют реализации по умолчанию.

Однако в отличие от классов мы не можем применять к интерфейсам модификатор **sealed**, чтобы запретить наследование интерфейсов.

Также мы не можем применять к интерфейсам модификатор **abstract**, поскольку интерфейс фактически итак, как правило, предоставляет абстрактный функционал, 
который должен быть реализован в классе или структуре (за исключением методов и свойств с реализацией по умолчанию).

Однако методы интерфейсов могут использовать ключевое слово **new** для сокрытия методов из базового интерфейса:

```cs
class RunAction : IRunAction
{
    public void Move()
    {
        Console.WriteLine("I am running");
    }
}

interface IAction
{
    void Move();
}
interface IRunAction : IAction
{
    new void Move();
}
```

Здесь метод Move из IRunAction скрывает метод Move из базового интерфейса IAction. Большого смысла в этом нет, 
так как в данном случае нечего скрывать, то тем не менее мы так можем делать. А класс RunAction реализует метод Move 
сразу для обоих интерфейсов.

При наследовании интерфейсов следует учитывать, что, как и при наследовании классов, производный интерфейс должен иметь 
тот же уровень доступа или более строгий, чем базовый интерфейс. Например:

```cs
public interface IAction
{
    void Move();
}
internal interface IRunAction : IAction
{
    void Run();
}
```

Но не наоборот. Например, в следующем случае мы получим ошибку, и программа не скомпилируется, так как производный 
интерфейс имеет менее строгий уровень доступа, нежели базовый:

```cs
internal interface IAction
{
    void Move();
}
public interface IRunAction : IAction    // ошибка IRunAction может быть только internal
{
    void Run();
}
```

