# Параллельное программирование и библиотека TPL

В эпоху многоядерных машин, которые позволяют параллельно выполнять сразу несколько процессов, стандартных средств работы с потоками в .NET 
уже оказалось недостаточно. Поэтому во фреймворк .NET была добавлена библиотека параллельных задач TPL (Task Parallel Library), 
основной функционал которой располагается в пространстве имен **System.Threading.Tasks**. 
Данная библиотека позволяет распараллелить задачи и выполнять их сразу на нескольких процессорах, если на целевом компьютере имеется 
несколько ядер. Кроме того, упрощается сама работа по созданию новых потоков. Поэтому начиная с .NET 4.0. рекомендуется использовать именно TPL и 
ее классы для создания многопоточных приложений, хотя стандартные средства и класс Thread по-прежнему находят широкое применение.

## Задачи и класс Task

В основе библиотеки TPL лежит концепция задач, каждая из которых описывает отдельную продолжительную операцию. 
В библиотеке классов .NET задача представлена специальным классом  - классом **Task**, который находится в пространстве 
имен **System.Threading.Tasks**. Данный класс описывает отдельную задачу, которая запускается асинхронно в одном из 
потоков из пула потоков. Хотя ее также можно запускать синхронно в текущем потоке.

Для определения и запуска задачи можно использовать различные способы. Первый способ создание объекта Task и вызов у него метода Start:

```cs
Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
```

В качестве параметра объект Task принимает делегат Action, то есть мы можем передать любое действие, которое соответствует данному делегату, 
например, лямбда-выражение, как в данном случае, или ссылку на какой-либо метод. То есть в данном случае при выполнении задачи на консоль будет выводиться строка "Hello Task!".

А метод `Start()` собственно запускает задачу.

Второй способ заключается в использовании статического метода **Task.Factory.StartNew()**. Этот метод также в качестве 
параметра принимает делегат Action, который указывает, какое действие будет выполняться. При этом этот метод сразу же запускает задачу:

```cs
Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
```

В качестве результата метод возвращает запущенную задачу.

Третий способ определения и запуска задач представляет использование статического метода **Task.Run()**:

```cs
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));
```

Метод `Task.Run()` также в качестве параметра может принимать делегат Action - выполняемое действие и возвращает объект Task.

Определим небольшую программу, где используем все эти способы:

```cs
using System;
using System.Threading.Tasks;

namespace HelloApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Task task1 = new Task(() => Console.WriteLine("Task1 is executed"));
            task1.Start();

            Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task2 is executed"));

            Task task3 = Task.Run(() => Console.WriteLine("Task3 is executed"));
            
            Console.ReadLine();
        }
    }
}
```

### Ожидание задачи

Важно понимать, что задачи не выполняются последовательно. Первая запущенная задача может завершить свое выполнение после последней задачи.

Или рассмотрим еще один пример:

```cs
using System;
using System.Threading;

namespace TaskApp
{
    class Program
    {
        static void Main(string[] args)
        {
            Task task = new Task(Display);
            task.Start();
            
            Console.WriteLine("Завершение метода Main");

            Console.ReadLine();
        }

        static void Display()
        {
            Console.WriteLine("Начало работы метода Display");

            Console.WriteLine("Завершение работы метода Display");
        }
    }
}
```

Класс `Task` в качестве параметра принимает метод Display, который соответствует делегату Action. 
Далее чтобы запустить задачу, вызываем метод Start: `task.Start()`, и после этого метод Display начнет выполняться во вторичном потоке. В конце 
метода Main выводит некоторый маркер-строку, что метод Main завершился.

Однако в данном случае консольный вывод может выглядеть следующим образом:

То есть мы видим, что даже когда основной код в методе Main уже отработал, запущенная ранее задача еще не завершилась.




Чтобы указать, что метод Main должен подождать до конца выполнения задачи, нам надо использовать метод `Wait`:

```cs
static void Main(string[] args)
{
    Task task = new Task(Display);
    task.Start();
    task.Wait();
    Console.WriteLine("Завершение метода Main");
    Console.ReadLine();
}
```

### Свойства класса Task

Класс Task имеет ряд свойств, с помощью которых мы можем получить информацию об объекте. Некоторые из них:

- **AsyncState**: возвращает объект состояния задачи

- **CurrentId**: возвращает идентификатор текущей задачи

- **Exception**: возвращает объект исключения, возникшего при выполнении задачи

- **Status**: возвращает статус задачи

