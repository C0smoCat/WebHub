## Частичные классы и методы

Классы могут быть частичными. То есть мы можем иметь несколько файлов с определением одного и того же класса, и при компиляции все 
эти определения будут скомпилированы в одно.

Например, определим в проекте два файла с кодом. Не столь важно как эти файлы будут называться. Например, PersonBase.cs и PersonAdditional.cs. 
В одном из этих файлов (без разницы в каком именно) определим следующий класс:

```cs
public partial class Person
{
    public void Move()
    {
        Console.WriteLine("I am moving");
    }
}
```

А в другом файле определим следующий класс:

```cs
public partial class Person
{
    public void Eat()
    {
        Console.WriteLine("I am eating");
    }
}
```

Таким образом, два файла в проекте содержит определение одного и того же класса Person, которые содержат два разных метода. И оба определенных здесь класса 
являются частичными. Для этого они определяются с ключевым словом **partial**.

![](https://metanit.com/web/javascript/./pics/3.14.png)

Затем мы можем использовать все методы класса Person:

```cs
class Program
{
    static void Main(string[] args)
    {
        Person tom = new Person();
        tom.Move();
        tom.Eat();

        Console.ReadKey();
    }
}
```

### Частичные методы

Частичные классы могут содержать частичные методы. Таким методы также опреляются с ключевым словом **partial**. Причем 
определение частичного метода без тела метода находится в одном частичном классе, а реализация этого же метода - в другом частичном классе.

Например, изменим выше определенные классы Person. Первый класс:

```cs
public partial class Person
{
    partial void DoSomethingElse();

    public void DoSomething()
    {
        Console.WriteLine("Start");
        DoSomethingElse();
        Console.WriteLine("Finish");
    }
}
```

Второй класс:

```cs
public partial class Person
{
    partial void DoSomethingElse()
    {
        Console.WriteLine("I am reading a book");
    }
}
```

В первом классе определен метод DoSomethingElse, который вызывается в методе DoSomething. Причем на момент определения первого класса неизвестно, 
что представляет собой метод DoSomethingElse. Тем не менее мы знаем список его параметров и может вызвать в первом классе.

Второй класс уже непосредственно определяет тело метода DoSomethingElse.

При этом частичные методы не могут иметь модификаторов доступа - по умолчанию они все считаются приватными. Также частичные методы 
не могут иметь таких модификаторов как `virtual, abstract, override, new, sealed`. Хотя допустимы статические частичные методы.

Кроме того, частичные методы не могут возвращать значения, то есть они всегда имеют тип **void**. И также они не могут иметь out-параметров.

Поскольку частичные методы всегда приватные, то мы не сможем иx вызвать напрямую в программе вне классов, где они определены. Поэтому 
обычно они вызываются через другие доступные методы как в случае выше через метод DoSomething:

```cs
Person tom = new Person();
tom.DoSomething();
```

