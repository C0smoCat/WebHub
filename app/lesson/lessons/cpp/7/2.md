## Вектор

Вектор представляет контейнер, который содержит коллекцию объектов одного типа. Для работы с векторами необходимо включить заголовок:

```cpp
#include <vector>
```

Определим простейший вектор:

```cpp
std::vector<int> numbers;
```

В угловых скобках указывается тип, объекты которого будут храниться в векторе. То есть вектор numbers хранит объекты типа int. Однако такой вектор пуст. Он не содержит никаких элементов.

Но мы можем инициализировать вектор одним из следующих способов:

```cpp
std::vector<int> v1;                // пустой вектор
std::vector<int> v2(v1);            // вектор v2 - копия вектора v1
std::vector<int> v3 = v1;            // вектор v3 - копия вектора v1
std::vector<int> v4(5);                // вектор v4 состоит из 5 чисел
std::vector<int> v5(5, 2);            // вектор v5 состоит из 5 чисел, каждое число равно 2
std::vector<int> v6{1, 2, 4, 5};    // вектор v6 состоит из чисел 1, 2, 4, 5
std::vector<int> v7 = {1, 2, 3, 5}; // вектор v7 состоит из чисел 1, 2, 4, 5
```

Важно понимать отличие в данном случае круглых скобок от фигурных:

```cpp
std::vector<int> v1(5);        // вектор состоит из 5 чисел, каждое число в векторе равно 0
std::vector<int> v2{5};        // вектор состоит из одного числа, которое равно 5
std::vector<int> v3(5, 2);    // вектор состоит из 5 чисел, каждое число равно 2
std::vector<int> v4{5, 2};    // вектор состоит из двух чисел 5 и 2
```

При этом можно хранить в векторе элементы только одного типа, который указан в угловых скобках. Значения дугих типов в вектор сохранить нельзя, как например, в следующем случае:

```cpp
std::vector<int> v{5, "hi"};
```

### Обращение к элементам и их перебор

Для обращения к элементам вектора можно использовать разные способы:

- **[index]**: получение элемента по индексу (также как и в массивах), индексация начинается с нуля

- **at(index)**: функция возращает элемент по индексу

- **front()**: возвращает первый элемент

- **back()**: возвращает последний элемент

Выполним перебор вектора и получим некоторые его элементы:

```cpp
#include <iostream>
#include <vector>
 
int main()
{
    std::vector<int> numbers= {1, 2, 3, 4, 5};
    
    int n1 = numbers.front();    // n1 = 1
    int n2 = numbers.back();    // n2 = 5
    int x = numbers[1]; // x = 2
    numbers[0] = 6;
    
    for (int n : numbers)
        cout << n << "\t";    // 6  2  3  4  5
    
    std::cout << std::endl;
    return 0;
}
```

При этом следует учитывать, что индексация не добавляет элементов. Например, если вектор содержит 5 элементов, то мы не можем обратиться к шестому элементу:

```cpp
std::vector<int> numbers= {1, 2, 3, 4, 5};
numbers[5] = 9;
```

При таком обращении результат неопределен. Некоторые комиляторы могут генерировать ошибку, некоторые продолжат работать, но даже в этом случае такое обращение будет ошибочно, и оно в любом случае не добавит в вектор шестой элемент.

Чтобы избежать подобных ситуаций, можно использовать функцию **at()**, которая хотя также возвращает элемент по индексу, но при попытке обращения по недопустимому индексу будет генерировать исключение **out_of_range**:

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

int main()
{
    std::vector<int> numbers = { 1, 2, 3, 4, 5};
    try
    {
        int n = numbers.at(8);
    }
    catch (std::out_of_range e)
    {
        std::cout << "Incorrect index" << std::endl;
    }

    return 0;
}
```


> Материал взят с сайта metanit.com