## List

Контейнер **list** представляет двухсвязный список. Для его использования необходимо подключить заголовочный файл **list**.

Создание списка:

```cpp
std::list<int> list1;                // пустой список
std::list<int> list2(5);            // список list2 состоит из 5 чисел, каждый элемент имеет значение по умолчанию
std::list<int> list3(5, 2);            // список list3 состоит из 5 чисел, каждое число равно 2
std::list<int> list4{ 1, 2, 4, 5 };    // список list4 состоит из чисел 1, 2, 4, 5
std::list<int> list5 = { 1, 2, 3, 5 }; // список list5 состоит из чисел 1, 2, 4, 5
std::list<int> list6(list4);          // список list6 - копия списка list4
std::list<int> list7 = list4;         // список list7 - копия списка list4
```

### Получение элементов

В отличие от других контейнеров для типа list не определена операция обращения по индексу или функция at(), которая выполняет похожую задачу.

Тем не менее для контейнера list можно использовать функции **front()** и **back()**, которые возвращают соответственно первый и последний элементы.

Чтобы обратиться к элементам, которые находятся в середине (после первого и до последнего элементов), придется выполнять перебор элементов с помощью циклов или итераторов:

```cpp
#include <iostream>
#include <list>

int main()
{
    std::list<int> numbers = { 1, 2, 3, 4, 5 };

    int first = numbers.front();  // 1
    int last = numbers.back();    // 5

    // перебор в цикле
    for (int n : numbers)
        std::cout << n << "\t";
    std::cout << std::endl;

    // перебор с помощью итераторов
    for (auto iter = numbers.begin(); iter != numbers.end(); iter++)
    {
        std::cout << *iter << "\t";
    }
    std::cout << std::endl;
    return 0;
}
```

### Размер списка

Для получения размера списка можно использовать функцию **size()**:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };
int size = numbers.size();     // 5
```

Функция **empty()** позволяет узнать, пуст ли список. Если он пуст, то функция возвращает значение true, иначе возвращается значение false:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };
if (numbers.empty())
    std::cout << "The list is empty" << std::endl;
else
    std::cout << "The list is not empty" << std::endl;
```

С помощью функции **resize()** можно изменить размер списка. Эта функция имеет две формы:

- **resize(n)**: оставляет в списке n первых элементов. Если список содержит больше элементов, то он усекается до первых n элементов. 
Если размер списка меньше n, то добавляются недостающие элементы и инициализируются значением по умолчанию

- **resize(n, value)**: также оставляет в списке n первых элементов. Если размер списка меньше n, то добавляются 
недостающие элементы со значением value

Применение функции:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5, 6 };
numbers.resize(4);    // оставляем первые четыре элемента - numbers = {1, 2, 3, 4}

numbers.resize(6, 8);     // numbers = {1, 2, 3, 4, 8, 8}
```

### Изменение элементов списка

Функция **assign()** позволяет заменить все элементы списка определенным набором. Она имеет следующие формы:

- **assign(il)**: заменяет содержимое контейнера элементами из списка инициализации il

- **assign(n, value)**: заменяет содержимое контейнера n элементами, которые имеют значение value

- **assign(begin, end)**: заменяет содержимое контейнера элементами из диапазона, на начало и конец которого 
указывают итераторы begin и end

Применение функции:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };

numbers.assign({ 21, 22, 23, 24, 25 }); // numbers = { 21, 22, 23, 24, 25 }

numbers.assign(4, 3);        // numbers = {3, 3, 3, 3}

std::list<int> values = { 6, 7, 8, 9, 10, 11 };
auto start = ++values.begin();    // итератор указывает на второй элемент из values
auto end = values.end();
numbers.assign(start, end); //  numbers = { 7, 8, 9, 10, 11 }
```

Функция **swap()** обменивает значениями два списка:

```cpp
std::list<int> list1 = { 1, 2, 3, 4, 5 };
std::list<int> list2 = { 6, 7, 8, 9};
list1.swap(list2);
// list1 = { 6, 7, 8, 9};
// list2 = { 1, 2, 3, 4, 5 };
```

### Добавление элементов

Для добавления элементов в контейнер list применяется ряд функций.

- **push_back(val)**: добавляет значение val в конец списка

- **push_front(val)**: добавляет значение val в начало списка

- **emplace_back(val)**: добавляет значение val в конец списка

- **emplace_front(val)**: добавляет значение val в начало списка

- **emplace(pos, val)**: вставляет элемент val на позицию, на которую указывает итератор pos. Возвращает итератор на 
добавленный элемент

- **insert(pos, val)**: вставляет элемент val на позицию, на которую указывает итератор pos, аналогично функции emplace. Возвращает итератор на 
добавленный элемент

- **insert(pos, n, val)**: вставляет n элементов val начиная с позиции, на которую указывает итератор pos. Возвращает итератор на 
первый добавленный элемент. Если n = 0, то возвращается итератор pos.

- **insert(pos, begin, end)**: вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из 
диапазона между итераторами begin и end. Возвращает итератор на 
первый добавленный элемент. Если между итераторами begin и end нет элементов, то возвращается итератор pos.

- **insert(pos, values)**: вставляет список значений values начиная с позиции, на которую указывает итератор pos. Возвращает итератор на 
первый добавленный элемент. Если values не содержит элементов, то возвращается итератор pos.

Функции `push_back()`, `push_front()`, `emplace_back()` и `emplace_front()`:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };
numbers.push_back(23);    // { 1, 2, 3, 4, 5, 23 }
numbers.push_front(15);    // { 15, 1, 2, 3, 4, 5, 23 }
numbers.emplace_back(24);    // { 15, 1, 2, 3, 4, 5, 23, 24 }
numbers.emplace_front(14);    // { 14, 15, 1, 2, 3, 4, 5, 23, 24 }
```

Добавление в середину списка с помощью функции **emplace()**:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };
auto iter = ++numbers.cbegin();    // итератор указывает на второй элемент
numbers.emplace(iter, 8); // добавляем после первого элемента  numbers = { 1, 8, 2, 3, 4, 5};
```

Добавление в середину списка с помощью функции **insert()**:

```cpp
std::list<int> numbers1 = { 1, 2, 3, 4, 5 };
auto iter1 = numbers1.cbegin();    // итератор указывает на первый элемент
numbers1.insert(iter1, 0); // добавляем начало списка  
//numbers1 = { 0, 1, 2, 3, 4, 5};

std::list<int> numbers2 = { 1, 2, 3, 4, 5 };
auto iter2 = numbers2.cbegin();    // итератор указывает на первый элемент
numbers2.insert(++iter2, 3, 4); // добавляем после первого элемента три четверки  
//numbers2 = { 1, 4, 4, 4, 2, 3, 4, 5};

std::list<int> values = { 10, 20, 30, 40, 50 };
std::list<int> numbers3 = { 1, 2, 3, 4, 5 };
auto iter3 = numbers3.cbegin();    // итератор указывает на первый элемент
// добавляем в начало все элементы из values
numbers3.insert(iter3, values.begin(), values.end());
//numbers3 = { 10, 20, 30, 40, 50, 1, 2, 3, 4, 5};

std::list<int> numbers4 = { 1, 2, 3, 4, 5 };
auto iter4 = numbers4.cend();    // итератор указывает на позицию за последним элементом
// добавляем в конец список из трех элементов
numbers4.insert(iter4, { 21, 22, 23 });
//numbers4 = { 1, 2, 3, 4, 5, 21, 22, 23};
```

### Удаление элементов

Для удаления элементов из контейнера list могут применяться следующ��е функции:

- **clear(p)**: удаляет все элементы

- **pop_back()**: удаляет последний элемент

- **pop_front()**: удаляет первый элемент

- **erase(p)**: удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, 
или на конец контейнера, если удален последний элемент

- **erase(begin, end)**: удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. 
Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент

Применение функций:

```cpp
std::list<int> numbers = { 1, 2, 3, 4, 5 };
numbers.pop_front();    // numbers = { 2, 3, 4, 5 }
numbers.pop_back();        // numbers = { 2, 3, 4 }
numbers.clear();    // numbers ={}

numbers = { 1, 2, 3, 4, 5 };
auto iter = numbers.cbegin(); // указатель на первый элемент
numbers.erase(iter);    // удаляем первый элемент
// numbers = { 2, 4, 5, 6 }

numbers = { 1, 2, 3, 4, 5 };
auto begin = numbers.begin(); // указатель на первый элемент
auto end = numbers.end();        // указатель на последний элемент
numbers.erase(++begin, --end);    // удаляем со второго элемента до последнего
//numbers = {1, 5}
```


> Материал взят с сайта metanit.com