## Типы исключений

Кроме типа exception в C++ есть еще несколько производных типов исключений, которые могут использоваться при различных ситуациях. Основные из них:

- **runtime_error**: общий тип исключений, которые возникают во время выполнения

- **range_error**: исключение, которое возникает, когда полученный результат превосходит допустимый диапазон

- **overflow_error**: исключение, которое возникает, если полученный результат превышает допустимый диапазон

- **underflow_error**: исключение, которое возникает, если полученный в вычислениях результат имеет недопустимые отрицательное значение (выход за нижнюю допустимую границу значений)

- **logic_error**: исключение, которое возникает при наличии логических ошбок к коде программы

- **domain_error**: исключение, которое возникает, если для некоторого значения, передаваемого в функцию, не определено результата

- **invalid_argument**: исключение, которое возникает при передаче в функцию некорректного аргумента

- **length_error**: исключение, которое возникает при попытке создать объект большего размера, чем допустим для данного типа

- **out_of_range**: исключение, которое возникает при попытке доступа к элементам вне допустимого диапазона

![Типы исключений в C++ и std::exception](https://metanit.com/cpp/tutorial/pics/6.1.png)

Большинство этих типов определено в заголовочном файле **stdexcept**, за исключением класса **bad_alloc**, 
который определн в файле **new**, и класса **bad_cast**, который определен в файле 
**type_info**.

В отличие от классов exception, bad_alloc и bad_cast в конструкторы других типов можно передать строку, то есть таким образом можно передать сообщение об ошибке.

Конструкция try...catch может использовать несколько блоков catch для обработки различных типов исключений. При возникновении исключения 
для его обработки будет выбран тот, который использует тип возникшего исключения.

При использовании нескольких блоков catch вначале помещаются блоки catch, которые обрабатывают более частные исключения, а только потом блоки catch с более 
общими типами исключений:

```cpp
#include <iostream>
#include <exception>
#include <stdexcept>

double divide(int, int);

int main()
{
    int x = 500;
    int y = 0;
    try
    {
        double z = divide(x, y);
        std::cout << z << std::endl;
    }
    catch (std::overflow_error err)
    {
        std::cout << "Overflow_error: " << err.what() << std::endl;
    }
    catch (std::runtime_error err)
    {
        std::cout << "Runtime_error: " << err.what() << std::endl;
    }
    catch (std::exception err)
    {
        std::cout << "Exception!!!"<< std::endl;
    }
    std::cout << "The End..." << std::endl;
    return 0;
}

double divide(int a, int b)
{
    if (b == 0)
        throw std::runtime_error("Division by zero!");
    return a / b;
}
```

Здесь функция divide, если параметр b равен 0, выбрасывает исключение типа **runtime_error**. Исключение инициализируется 
сообщением об ошибке "Division by zero!".

В функции main конструкция try..catch использует три блока catch. Причем последний блок представляет самый общий тип исключений exception. Второй блок 
обрабатывает исключения типа runtime_error, производный от exception. А первый блок обрабатывает исключения типа overflow_error, который является производным от 
runtime_error.

Также все типы исключений имеют метод **what()**, который возвращает информацию об ошибке. И в данном случае программа выдаст следующий результат:

```

```

