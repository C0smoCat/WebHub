## Строки

Для хранения строк в C++ применяется тип **string**. Для использования этого типа его необходимо подключить в код с помощью директивы **include**:

```cpp
#include <string>
#include <iostream>

int main()
{
    std::string hello = "Hello World!";
    std::cout << hello << "\n";
    return 0;
}
```

Тип string определен в стандартной библиотеке и при его использовании надо указывать пространство имен **std**.

Либо можно использовать выражение using, чтобы не указывать префикс std:

```cpp
using std::string;
```

В данном случае значение переменной hello, которая представляет тип string, выводится на консоль.

При компиляции через g++ может потребоваться указать флаг **-static**. То есть если код определен в файл hello.cpp, то команда на компиляцию для g++ может выглядеть следующим образом:

```cpp
g++ hello.cpp -o hello -static
```

Для инициализации строк можно использовать различные способы:

```cpp
#include <string>
#include <iostream>

int main()
{
    std::string s1;                    // пустая строка
    std::string s2 = "hello";        // hello
    std::string s3("welcome");        // welcome
    std::string s4(5, 'h');        // hhhhh
    std::string s5 = s2;            // hello
    
    std::cout << s1 << "\n";
    std::cout << s2 << "\n";
    std::cout << s3 << "\n";
    std::cout << s4 << "\n";
    std::cout << s5 << "\n";
    return 0;
}
```

Консольный вывод данной программы:

```

```

Если при определении переменной типа string мы не присваиваем ей никакого значения, то по умолчанию данная переменная содержит пустую строку:

```cpp
std::string s1;
```

Также можно инициализировать переменную строчным литералом, который заключается в двойные кавычки:

```cpp
std::string s2 = "hello";
```

В качестве альтернативы можно передавать строку в скобках после определения переменной:

```cpp
std::string s3("welcome");
```

Если необходимо, чтобы строка содержала определенное количесто определеных символов, то можно указать в скобках количество символов и сам символ:

```cpp
std::string s4(5, 'h');
```

И также можно передать переменной копию другой строки:

```cpp
std::string s5 = s2;
```

### Конкатенация строк

Над строками можно выполнять ряд операций. В частности, можно объединять строки с помощью стандартной операции сложения:

```cpp
#include <iostream>
using std::cout;
using std::endl;
using std::string;

int main()
{    
    string s1 = "hello";
    string s2 = "world";
    string s3 = s1 + " " + s2; // hello world
    cout << s3 << endl;
    return 0;
}
```

### Сравнение строк

К строкам можно применять операции сравнения. Оператор **==** возвращает true, если все символы обеих строк равны.

```cpp
std::string s1 = "hello";
std::string s2 = "world";

bool result = s1 == s2;        // false
result = s1 == "Hello";     // false
result = s1 == "hello";     // true
```

При этом символы должны совпадать в том числе по регистру.

Операция **!=** возвращает true, если две строки не совпадают.

```cpp
std::string s1 = "hello";
std::string s2 = "world";

bool result = s1 != s2;        // true
result = s1 != "Hello";     // true
result = s1 != "hello";     // false
```

Остальные базовые операции сравнения **<**, **<=**, **>**, **>=** сравнивают строки в зависимости от регистра и алфавитного порядка символов. Например, строка "b" условно больше строки "a", так как символ b по алфавиту идет после символа a. А строка "a" больше строки "A". Если первые символы строки равны, то сравниваются последующие символы:

```cpp
std::string s1 = "Aport";
std::string s2 = "Apricot";
bool result = s1 > s2;        // false
```

В данном случае условие s1 > s2 ложно, то есть s2 больше чем s1, так как при равенстве первых двух символов ("Ap") третий символ второй строки ("o") стоит в алфавите до третьего символа второй строки ("p"), то есть "o" меньше чем "p".

### Размер строки

С помощью метода **size()** можно узнать размер строки, то есть из скольких символов она состоит:

```cpp
std::string s1 = "hello";
std::cout << s1.size() << std::endl;    // 5
```

Если строка пустая, то она содержит 0 символов. В этом случае мы можем применить метод **empty()** - он возвращает true, если строка пустая:

```cpp
std::string s1 = "";
if (s1.empty())
    std::cout << "String is empty" << std::endl;
```

### Чтение строки с консоли

Для считывания введенной строки с консоли можно использовать объект std::cin:

```cpp
#include <iostream>
#include <string>

int main()
{    
    std::string name;
    std::cout << "Input your name: ";
    std::cin >> name;
    std::cout << "Your name: " << name << std::endl;
    return 0;
}
```

Консольный вывод:

```

```

Однако если при данном способе ввода строка будет содержать подстроки, разделенные пробелом, то std::cin будет использовать только первую подстроку:

```

```

Чтобы считать всю строку, применяется метод **getline()**:

```cpp
#include <iostream>
#include <string>

int main()
{    
    std::string name;
    std::cout << "Input your name: ";
    getline(std::cin, name);
    std::cout << "Your name: " << name << std::endl;
    return 0;
}
```

Метод getline принимает два объекта - std::cin и переменную, в которую надо считать строку.

Консольный вывод:

```

```

### Получение и изменение символов строки

Подобно массиву мы можем обращаться с помощью индексов к отдельным символам строки, получать и изменять их:

```cpp
std::string hello = "Hello";
char c = hello[1];        // e
hello[0]='M';
std::cout << hello << std::endl;    // Mello
```

### Символьные массивы

Массив символов, последний элемент которого представляет нулевой символ '\0', может использоваться как строка:

```cpp
#include <iostream>
 
int main()
{
    char letters[] = {'h', 'e', 'l', 'l', 'o', '\0'};
    std::cout << letters << std::endl;
    
    return 0;
}
```

Данный код выведет на консоль строку "hello". Подобное определение массива строк будет также эквивалентно следующему:

```cpp
char letters[] = "hello";
```

Однако подобное использование массива строк унаследовано от языка Си, а при написании программ на С++ при работе со строками следует отдавать предпочтение встроенному типу string, а не массиву символов.


> Материал взят с сайта metanit.com