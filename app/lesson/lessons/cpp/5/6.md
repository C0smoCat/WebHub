## Ключевое слово this

Ключевое слово this представляет указатель на текущий объект данного класса. Соответственно через this мы можем обращаться внутри класса к любым его членам.

```cpp
#include <iostream>

class Point
{
public:
    Point(int x, int y)
    {
        this->x = x; 
        this->y = y;
    }
    void showCoords() 
    {
        std::cout << "Coords x: " << this->x << "\t y: " << y << std::endl;
    }
private:
    int x;
    int y;
};

int main()
{
    Point p1(20, 50);
    p1.showCoords();

    return 0;
}
```

В данном случае определен класс Point, который представляет точку на плоскости. И для хранения координат точки в классе определены переменные x и y.

Для обращения к переменным используется указатель **this**. Причем после this ставится не точка, а стрелка **->**.

В большинстве случаев для обращения к членам класса вряд ли поднадобится ключевое слово this. Но оно может быть необходимо, если параметры функции или переменные, которые 
определяются внутри функции, называются также как и переменные класса. К примеру, чтобы в конструкторе разграничить параметры и переменные класса как раз и используется указатель 
this.

С помощью this можно возвращать текущий объект класса:

```cpp
#include <iostream>

class Point
{
public:
    Point(int x, int y)
    {
        this->x = x; 
        this->y = y;
    }
    void showCoords() 
    {
        std::cout << "Coords x: " << x << "\t y: " << y << std::endl;
    }
    Point &move(int x, int y)
    {
        this->x += x;
        this->y += y;
        return *this;
    }
private:
    int x;
    int y;
};

int main()
{
    Point p1(20, 50);
    p1.move(10, 5).move(10, 10);
    p1.showCoords(); // x: 40  y: 65

    return 0;
}
```

Здесь метод move с помощью указателя this возвращает ссылку на объект текущего класса, осуществляя условное перемещение точки. Таким образом, мы можем по цепочке для одного и того же объекта вызывать метод move:

```cpp
p1.move(10, 5).move(10);
```

Здесь также важно отметить возвращение не просто объекта Point, а ссылки на этот объект. Так, в данном случае выге определенная строка фактически будет аналогично следующему коду:

```cpp
p1.move(10, 5);
p1.move(10, 10);
```

Но если бы метод move возвращал бы не ссылку, а посто объект:

```cpp
Point move(int x, int y)
{
    this->x += x;
    this->y += y;
    return *this;
}
```

То вызов `p1.move(10, 5).move(10)` был бы фактически эквивалентен следующему коду:

```cpp
Point temp = p1.move(10, 5);
temp.move(10, 10);
```

Где второй вызов метода move вызывался бы для временной копии и никак бы не затрагивал переменную p1.

