## Структуры

Ранее для определения классов мы использовали ключевое слово **class**. Однако C++ предоставляет еще один способ 
для определения пользовательских типов, который заключается в использовании структур. Данный способ был унаследован языком С++ еще от языка Си.

Структура в языке C++ представляет собой производный тип данных, который представляет какую-то определенную сущность, также как и класс. 
Нередко структуры применителько к С++ также называют классами. И в реальности различия между ними не такие большие.

Для определения структуры применяется ключевое слово **struct**, а сам формат определения выглядит следующим образом:

```cpp
struct имя_структуры
{
    компоненты_структуры
};
```

**Имя_структуры** представляет произвольный идентификатор, к которому применяются те же правила, что и при наименовании переменных.

После имени структуры в фигурных скобках помещаются **Компоненты_структуры**, которые представляют набор описаний объектов и функций, которые составляют структуру.

Например, определим простейшую структуру:

```cpp
#include <iostream>
#include <string>

struct person
{
    int age;
    std::string name;
};

int main()
{
    person tom;
    tom.name = "Tom";
    tom.age = 34;
    std::cout << "Name: " << tom.name << "\tAge: " << tom.age << std::endl;
    return 0;
}
```

Здесь определена структура `person`, которая имеет два элемента: `age` (представляет тип int) и `name` 
(представляет тип string).

После определения структуры мы можем ее использовать. Для начала мы можем определить объект структуры - по сути обычную переменную, которая будет 
представлять выше созданный тип. Также после создания переменной структуры можно обращаться к ее элементам - получать их значения или, наоборот, присваивать им новые значения. 
Для обращения к элементам структуры используется операция "точка":

```cpp
имя_переменной_структуры.имя_элемента
```

По сути структура похожа на класс, то есть с помощью структур также можно определять сущности для использования в программе. В то же время 
все члены структуры, для которых не используется спецификатор доступа (public, private), по умолчанию являются открытыми (public). 
Тогда как в классе все его члены, для которых не указан спецификатор доступа, являются закрытыми (private).

Кроме того мы можем инициализировать структуру, присвоив ее переменным значения с помощью синтаксиса инициализации:

```cpp
person tom = { 34, "Tom" };
```

Инициализация структур аналогична инициализации массивов: в фигурных скобках передаются значения для элементов структуры по порядку. Так как 
в структуре person первым определено свойство, которое представляет тип int - число, то в фигурных скобках вначале идет число. 
И так далее для всех элементов структуры по порядку.

При этом любой класс мы можем представить в виде структуры и наоборот. Возьмем, к примеру, следующий класс:

```cpp
class Person
{
public:
    Person(std::string n, int a)
    {
        name = n; age = a;
    }
    void move()
    {
        std::cout << name << " is moving" << std::endl;
    }
    void setAge(int a)
    {
        if (a > 0 && a < 100) age = a;
    }
    std::string getName()
    {
        return name;
    }
    int getAge()
    {
        return age;
    }
private:
    std::string name;
    int age;

};
```

Данный класс определяет сущность человека и содержит ряд приватных и публичных переменных и функции. Вместо класса для определения той же сущности мы могли 
бы использовать структуру:

```cpp
#include <iostream>
#include <string>

struct user
{
public:
    user(std::string n, int a)
    {
        name = n; age = a;
    }
    void move()
    {
        std::cout << name << " is moving" << std::endl;
    }
    void setAge(int a)
    {
        if (a > 0 && a < 100) age = a;
    }
    std::string getName()
    {
        return name;
    }
    int getAge()
    {
        return age;
    }
private:
    std::string name;
    int age;

};

int main()
{
    user tom("Tom", 22);
    std::cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << std::endl;
    tom.setAge(31);
    std::cout << "Name: " << tom.getName() << "\tAge: " << tom.getAge() << std::endl;
    return 0;
}
```

И в плане конечного результата программы мы не увидели бы никакой разницы.

Когда использовать структуры? Как правило, структуры используются для описания таких данных, которые имеют только набор публичных атрибутов - открытых переменных. Например, как та же структура person, которая 
была определена в начале статьи. Иногда подобные сущности еще называют **аггрегатными классами** (aggregate classes).

